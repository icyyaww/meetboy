# Turms 新业务功能开发指南

本文档详细介绍了在 Turms 即时通讯系统中添加新业务功能的完整流程。

## 📝 最新代码修改记录

### 2025-06-18 架构优化分析
- **修改内容**：创建了用户模块与消息模块拆分难度评估报告
- **新增文件**：`/home/icyyaww/program/meetboy/docs/architecture-optimization/04-user-messaging-module-separation-difficulty-assessment.md`
- **修改原因**：深入分析Turms系统微服务化拆分的技术可行性和实施难度，为后续架构优化决策提供详细的技术依据
- **影响范围**：架构设计文档，不涉及代码变更
- **主要发现**：
  - 用户模块与消息模块高度耦合，拆分难度极高
  - 当前不建议进行微服务化拆分
  - 推荐采用模块化重构的渐进式优化方案
- **技术要点**：
  - 代码层面：48个文件引用user模块，18个文件引用message模块
  - 数据层面：消息表通过sender_id和target_id强关联用户表
  - 服务层面：需要处理复杂的分布式事务和状态同步
  - 性能影响：预估响应延迟增加2-5倍
  - 实施成本：约200万成本，9个月开发周期

## 🚀 开发流程概述

添加新业务功能需要遵循以下步骤：
1. 定义 Proto 协议
2. 生成代码
3. 服务端实现
4. 网关层配置  
5. 客户端使用
6. 数据库设计
7. 配置管理
8. 测试
9. 文档更新

## 1. 📋 定义 Proto 协议

### 创建新的请求类型
```protobuf
// 在 turms_request.proto 中添加新的请求类型
message CreateCustomBusinessRequest {
    optional string business_name = 1;
    optional string business_data = 2;
    repeated int64 target_user_ids = 3;
    optional int64 group_id = 4;
}

// 在 TurmsRequest 的 oneof 中添加
message TurmsRequest {
    // ... 现有请求类型
    oneof kind {
        // ... 现有的72种请求
        CreateCustomBusinessRequest create_custom_business_request = 100;
        UpdateCustomBusinessRequest update_custom_business_request = 101;
        QueryCustomBusinessRequest query_custom_business_request = 102;
    }
}
```

### 创建对应的响应和通知
```protobuf
// 在相应的 proto 文件中定义响应
message CreateCustomBusinessResponse {
    optional int64 business_id = 1;
    optional int64 timestamp = 2;
}

// 在通知中添加
message CustomBusinessNotification {
    optional int64 business_id = 1;
    optional string business_name = 2;
    optional int64 creator_id = 3;
}
```

### Proto 设计原则
- 新字段使用 `optional` 标记以保持向后兼容性
- 为字段分配唯一的编号
- 避免重复使用已废弃的字段编号
- 使用描述性的字段名称

## 2. 🔧 生成代码

### 重新生成所有客户端代码
```bash
# 在项目根目录执行
./tools/generate_proto.sh

# 或者单独生成特定客户端
cd turms-client-js && npm run protoc:compile
cd turms-client-kotlin && ./generate_proto.sh
cd turms-client-dart && ./tool/generate_proto.sh
cd turms-client-swift && ./generate_proto.sh
cd turms-client-cpp && ./generate_proto.sh
```

### 验证生成结果
```bash
# 检查生成的 Java 文件
find . -name "*CustomBusiness*.java" -type f

# 检查生成的 TypeScript 文件  
find . -name "*custom-business*.ts" -type f
```

## 3. 🏗️ 服务端实现

### 创建业务服务类
```java
@Service
public class CustomBusinessService {
    
    private final CustomBusinessRepository customBusinessRepository;
    private final TurmsPropertiesManager propertiesManager;
    private final TurmsTaskExecutor taskExecutor;
    
    public CustomBusinessService(
            CustomBusinessRepository customBusinessRepository,
            TurmsPropertiesManager propertiesManager,
            TurmsTaskExecutor taskExecutor) {
        this.customBusinessRepository = customBusinessRepository;
        this.propertiesManager = propertiesManager;
        this.taskExecutor = taskExecutor;
    }
    
    public Mono<CreateCustomBusinessResponse> createCustomBusiness(
            Long requesterId,
            CreateCustomBusinessRequest request) {
        
        // 1. 验证请求参数
        if (StringUtil.isBlank(request.getBusinessName())) {
            return Mono.error(TurmsBusinessException
                .get(TurmsStatusCode.ILLEGAL_ARGUMENT, "Business name cannot be blank"));
        }
        
        // 2. 检查业务配置
        if (!propertiesManager.getLocalProperties()
                .getService().getCustomBusiness().isEnabled()) {
            return Mono.error(TurmsBusinessException
                .get(TurmsStatusCode.DISABLED_FUNCTION));
        }
        
        // 3. 验证权限
        return checkPermission(requesterId, request)
            .then(customBusinessRepository.createBusiness(
                    requesterId, 
                    request.getBusinessName(),
                    request.getBusinessData(),
                    request.getTargetUserIdsList(),
                    request.hasGroupId() ? request.getGroupId() : null))
            .map(businessId -> CreateCustomBusinessResponse.newBuilder()
                .setBusinessId(businessId)
                .setTimestamp(System.currentTimeMillis())
                .build());
    }
    
    private Mono<Void> checkPermission(Long requesterId, CreateCustomBusinessRequest request) {
        // 实现权限检查逻辑
        return Mono.empty();
    }
    
    public Mono<Void> deleteCustomBusiness(Long requesterId, Long businessId) {
        return customBusinessRepository.deleteByIdAndCreatorId(businessId, requesterId)
            .then();
    }
    
    public Flux<CustomBusiness> queryCustomBusinesses(
            Long requesterId, 
            QueryCustomBusinessRequest request) {
        return customBusinessRepository.findByCreatorId(requesterId)
            .take(request.hasLimit() ? request.getLimit() : 50);
    }
}
```

### 添加请求处理器
```java
@Component
public class CreateCustomBusinessRequestHandler 
        extends ClientRequestHandler<CreateCustomBusinessRequest> {

    private final CustomBusinessService customBusinessService;

    public CreateCustomBusinessRequestHandler(CustomBusinessService customBusinessService) {
        this.customBusinessService = customBusinessService;
    }

    @Override
    public Mono<RequestHandlerResult> handle(
            RequestHandlerResultFactory resultFactory,
            ClientRequest<CreateCustomBusinessRequest> clientRequest) {
        
        Long requesterId = clientRequest.requesterId();
        CreateCustomBusinessRequest request = clientRequest.turmsRequest()
            .getCreateCustomBusinessRequest();
            
        return customBusinessService.createCustomBusiness(requesterId, request)
            .map(response -> resultFactory.get(
                TurmsNotification.Data.newBuilder()
                    .setCreateCustomBusinessResponse(response)
                    .build()))
            .onErrorMap(throwable -> {
                if (throwable instanceof TurmsBusinessException) {
                    return throwable;
                }
                return TurmsBusinessException.get(TurmsStatusCode.SERVER_INTERNAL_ERROR);
            });
    }
}

@Component  
public class UpdateCustomBusinessRequestHandler
        extends ClientRequestHandler<UpdateCustomBusinessRequest> {
    // 类似的实现...
}

@Component
public class QueryCustomBusinessRequestHandler  
        extends ClientRequestHandler<QueryCustomBusinessRequest> {
    // 类似的实现...
}
```

### 注册请求处理器
```java
// 在 RequestHandlerManager 中注册新的处理器
@PostConstruct
private void registerHandlers() {
    // ... 现有处理器注册
    
    registerHandler(TurmsRequest.KindCase.CREATE_CUSTOM_BUSINESS_REQUEST, 
        CreateCustomBusinessRequestHandler.class);
    registerHandler(TurmsRequest.KindCase.UPDATE_CUSTOM_BUSINESS_REQUEST,
        UpdateCustomBusinessRequestHandler.class);  
    registerHandler(TurmsRequest.KindCase.QUERY_CUSTOM_BUSINESS_REQUEST,
        QueryCustomBusinessRequestHandler.class);
}
```

## 4. 🌐 网关层配置

### 添加请求验证器（可选）
```java
@Component
public class CustomBusinessRequestValidator 
        implements ClientRequestTransformer {
    
    private static final Logger LOGGER = LoggerFactory.getLogger(CustomBusinessRequestValidator.class);
    
    @ExtensionPointMethod
    @Override
    public Mono<ClientRequest> transform(@NotNull ClientRequest clientRequest) {
        TurmsRequest.Builder builder = clientRequest.turmsRequestBuilder();
        
        if (builder.getKindCase() == TurmsRequest.KindCase.CREATE_CUSTOM_BUSINESS_REQUEST) {
            CreateCustomBusinessRequest request = builder.getCreateCustomBusinessRequest();
            
            // 添加网关层验证逻辑
            if (request.getBusinessName().length() > 50) {
                LOGGER.warn("Business name too long: {}", request.getBusinessName());
                return Mono.error(TurmsBusinessException
                    .get(TurmsStatusCode.ILLEGAL_ARGUMENT, "Business name too long"));
            }
            
            // 可以添加限流、黑名单检查等
            return checkRateLimit(clientRequest)
                .then(Mono.just(clientRequest));
        }
        
        return Mono.just(clientRequest);
    }
    
    private Mono<Void> checkRateLimit(ClientRequest clientRequest) {
        // 实现限流逻辑
        return Mono.empty();
    }
}
```

## 5. 📱 客户端使用

### JavaScript 客户端
```javascript
// 自动生成的客户端 API
const turmsClient = new TurmsClient();

// 连接到服务器
await turmsClient.userService.login(userId, password);

// 使用新的业务功能
try {
    const response = await turmsClient.customBusinessService.createCustomBusiness({
        businessName: "新业务功能",
        businessData: JSON.stringify({ key: "value" }),
        targetUserIds: [123, 456],
        groupId: 789
    });
    
    console.log('业务创建成功，ID:', response.businessId);
} catch (error) {
    console.error('业务创建失败:', error);
}

// 查询业务
const businesses = await turmsClient.customBusinessService.queryCustomBusinesses({
    limit: 10
});

// 更新业务
await turmsClient.customBusinessService.updateCustomBusiness({
    businessId: businessId,
    businessName: "更新后的业务名称"
});
```

### Android/Kotlin 客户端
```kotlin
// 自动生成的客户端 API
val turmsClient = TurmsClient()

// 连接到服务器
turmsClient.userService.login(userId, password).block()

// 使用新的业务功能
try {
    val response = turmsClient.customBusinessService.createCustomBusiness(
        businessName = "新业务功能",
        businessData = """{"key": "value"}""",
        targetUserIds = listOf(123L, 456L),
        groupId = 789L
    ).block()
    
    println("业务创建成功，ID: ${response.businessId}")
} catch (e: Exception) {
    println("业务创建失败: ${e.message}")
}

// 查询业务
val businesses = turmsClient.customBusinessService.queryCustomBusinesses(
    limit = 10
).collectList().block()

// 更新业务  
turmsClient.customBusinessService.updateCustomBusiness(
    businessId = businessId,
    businessName = "更新后的业务名称"
).block()
```

### Flutter/Dart 客户端
```dart
// 自动生成的客户端 API
final turmsClient = TurmsClient();

// 连接到服务器
await turmsClient.userService.login(userId, password);

// 使用新的业务功能
try {
  final response = await turmsClient.customBusinessService.createCustomBusiness(
    businessName: '新业务功能',
    businessData: '{"key": "value"}',
    targetUserIds: [123, 456],
    groupId: 789,
  );
  
  print('业务创建成功，ID: ${response.businessId}');
} catch (e) {
  print('业务创建失败: $e');
}
```

## 6. 🗄️ 数据库设计

### MongoDB 实体类
```java
@Document(collection = "customBusiness")
public class CustomBusiness {
    @Id
    private Long id;
    
    @Field("business_name")
    @Indexed
    private String businessName;
    
    @Field("business_data") 
    private String businessData;
    
    @Field("creator_id")
    @Indexed
    private Long creatorId;
    
    @Field("target_user_ids")
    private Set<Long> targetUserIds;
    
    @Field("group_id")
    @Indexed
    private Long groupId;
    
    @Field("creation_date")
    @Indexed
    private Date creationDate;
    
    @Field("last_modified_date")
    private Date lastModifiedDate;
    
    @Field("status")
    @Indexed  
    private CustomBusinessStatus status;
    
    // 构造函数、getter、setter...
    
    public enum CustomBusinessStatus {
        ACTIVE,
        INACTIVE, 
        DELETED
    }
}
```

### Repository 实现
```java
@Repository
public class CustomBusinessRepository {
    
    private final MongoTemplate mongoTemplate;
    private final SnowflakeIdGenerator snowflakeIdGenerator;
    
    public CustomBusinessRepository(
            MongoTemplate mongoTemplate,
            SnowflakeIdGenerator snowflakeIdGenerator) {
        this.mongoTemplate = mongoTemplate;
        this.snowflakeIdGenerator = snowflakeIdGenerator;
    }
    
    public Mono<Long> createBusiness(
            Long creatorId, 
            String businessName, 
            String businessData,
            List<Long> targetUserIds,
            Long groupId) {
        
        CustomBusiness business = new CustomBusiness();
        business.setId(snowflakeIdGenerator.generateId());
        business.setCreatorId(creatorId);
        business.setBusinessName(businessName);
        business.setBusinessData(businessData);
        business.setTargetUserIds(targetUserIds != null ? new HashSet<>(targetUserIds) : null);
        business.setGroupId(groupId);
        business.setCreationDate(new Date());
        business.setStatus(CustomBusiness.CustomBusinessStatus.ACTIVE);
        
        return mongoTemplate.insert(business)
            .map(CustomBusiness::getId);
    }
    
    public Flux<CustomBusiness> findByCreatorId(Long creatorId) {
        Query query = Query.query(Criteria.where("creator_id").is(creatorId)
            .and("status").is(CustomBusiness.CustomBusinessStatus.ACTIVE));
        query.with(Sort.by(Sort.Direction.DESC, "creation_date"));
        
        return mongoTemplate.find(query, CustomBusiness.class);
    }
    
    public Mono<Boolean> deleteByIdAndCreatorId(Long businessId, Long creatorId) {
        Query query = Query.query(Criteria.where("id").is(businessId)
            .and("creator_id").is(creatorId));
        
        Update update = Update.update("status", CustomBusiness.CustomBusinessStatus.DELETED)
            .set("last_modified_date", new Date());
            
        return mongoTemplate.updateFirst(query, update, CustomBusiness.class)
            .map(result -> result.getModifiedCount() > 0);
    }
    
    public Mono<Boolean> existsByIdAndCreatorId(Long businessId, Long creatorId) {
        Query query = Query.query(Criteria.where("id").is(businessId)
            .and("creator_id").is(creatorId)
            .and("status").is(CustomBusiness.CustomBusinessStatus.ACTIVE));
            
        return mongoTemplate.exists(query, CustomBusiness.class);
    }
}
```

### 数据库索引配置
```javascript
// MongoDB 索引创建脚本
db.customBusiness.createIndex({ "creator_id": 1, "creation_date": -1 });
db.customBusiness.createIndex({ "group_id": 1, "status": 1 });
db.customBusiness.createIndex({ "target_user_ids": 1, "status": 1 });
db.customBusiness.createIndex({ "business_name": "text" }); // 支持文本搜索
```

## 7. 🔧 配置管理

### 业务配置属性
```java
@Data
@ConfigurationProperties("turms.service.custom-business")
public class CustomBusinessProperties {
    
    private boolean enabled = true;
    
    private int maxBusinessNameLength = 50;
    
    private int maxBusinessDataLength = 1000;
    
    private boolean allowAnonymousAccess = false;
    
    private int maxBusinessesPerUser = 100;
    
    private Duration businessCacheTtl = Duration.ofMinutes(30);
    
    private RateLimitProperties rateLimit = new RateLimitProperties();
    
    @Data
    public static class RateLimitProperties {
        private boolean enabled = true;
        private int requestsPerMinute = 10;
        private Duration windowSize = Duration.ofMinutes(1);
    }
}
```

### 应用配置文件
```yaml
# application.yaml
turms:
  service:
    custom-business:
      enabled: true
      max-business-name-length: 50
      max-business-data-length: 1000
      allow-anonymous-access: false
      max-businesses-per-user: 100
      business-cache-ttl: PT30M
      rate-limit:
        enabled: true
        requests-per-minute: 10
        window-size: PT1M

# application-dev.yaml (开发环境)
turms:
  service:
    custom-business:
      max-businesses-per-user: 1000  # 开发环境放宽限制
      rate-limit:
        requests-per-minute: 100

# application-prod.yaml (生产环境)  
turms:
  service:
    custom-business:
      rate-limit:
        requests-per-minute: 5  # 生产环境更严格
```

## 8. 🧪 测试

### 单元测试
```java
@ExtendWith(MockitoExtension.class)
class CustomBusinessServiceTest {
    
    @Mock
    private CustomBusinessRepository customBusinessRepository;
    
    @Mock
    private TurmsPropertiesManager propertiesManager;
    
    @InjectMocks
    private CustomBusinessService customBusinessService;
    
    @Test
    void createCustomBusiness_shouldReturnBusinessId_whenValidRequest() {
        // Given
        Long requesterId = 1L;
        CreateCustomBusinessRequest request = CreateCustomBusinessRequest.newBuilder()
            .setBusinessName("测试业务")
            .setBusinessData("测试数据")
            .build();
            
        when(customBusinessRepository.createBusiness(any(), any(), any(), any(), any()))
            .thenReturn(Mono.just(123L));
            
        when(propertiesManager.getLocalProperties())
            .thenReturn(createMockProperties(true));
            
        // When
        StepVerifier.create(customBusinessService.createCustomBusiness(requesterId, request))
            // Then
            .assertNext(response -> {
                assertThat(response.getBusinessId()).isEqualTo(123L);
                assertThat(response.getTimestamp()).isPositive();
            })
            .verifyComplete();
    }
    
    @Test
    void createCustomBusiness_shouldThrowException_whenBusinessNameIsBlank() {
        // Given
        CreateCustomBusinessRequest request = CreateCustomBusinessRequest.newBuilder()
            .setBusinessName("")
            .build();
            
        // When & Then
        StepVerifier.create(customBusinessService.createCustomBusiness(1L, request))
            .expectError(TurmsBusinessException.class)
            .verify();
    }
    
    private TurmsProperties createMockProperties(boolean enabled) {
        TurmsProperties properties = new TurmsProperties();
        properties.getService().getCustomBusiness().setEnabled(enabled);
        return properties;
    }
}
```

### 集成测试
```java
@SpringBootTest
@TestPropertySource(properties = {
    "turms.service.custom-business.enabled=true",
    "turms.service.custom-business.max-businesses-per-user=10"
})
class CustomBusinessServiceIT extends BaseIntegrationTest {
    
    @Autowired
    private CustomBusinessService customBusinessService;
    
    @Autowired
    private CustomBusinessRepository customBusinessRepository;
    
    @Test
    void createCustomBusiness_shouldPersistToDatabaseCorrectly() {
        // Given
        Long requesterId = 1L;
        CreateCustomBusinessRequest request = CreateCustomBusinessRequest.newBuilder()
            .setBusinessName("集成测试业务")
            .setBusinessData("{\"test\": true}")
            .addTargetUserIds(100L)
            .addTargetUserIds(200L)
            .setGroupId(300L)
            .build();
            
        // When
        CreateCustomBusinessResponse response = customBusinessService
            .createCustomBusiness(requesterId, request)
            .block();
            
        // Then
        assertThat(response).isNotNull();
        assertThat(response.getBusinessId()).isPositive();
        
        // 验证数据库中的数据
        StepVerifier.create(customBusinessRepository.findByCreatorId(requesterId))
            .assertNext(business -> {
                assertThat(business.getBusinessName()).isEqualTo("集成测试业务");
                assertThat(business.getTargetUserIds()).containsExactly(100L, 200L);
                assertThat(business.getGroupId()).isEqualTo(300L);
            })
            .verifyComplete();
    }
}
```

### API 测试
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class CustomBusinessApiIT {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Test
    void createCustomBusiness_throughApi_shouldReturnSuccess() {
        // 模拟完整的 API 调用流程
        TurmsRequest turmsRequest = TurmsRequest.newBuilder()
            .setCreateCustomBusinessRequest(
                CreateCustomBusinessRequest.newBuilder()
                    .setBusinessName("API测试业务")
                    .setBusinessData("API测试数据")
                    .build())
            .build();
            
        // 发送请求并验证响应
        // ... API 测试逻辑
    }
}
```

## 9. 📚 文档更新

### API 文档
```markdown
## Custom Business API

### Create Custom Business
创建自定义业务实例。

**请求类型**: `CREATE_CUSTOM_BUSINESS_REQUEST`

**权限要求**: 已登录用户

**请求参数**:
- `business_name` (string, 必填): 业务名称，最大长度50字符
- `business_data` (string, 可选): 业务数据，最大长度1000字符，建议使用JSON格式
- `target_user_ids` (int64[], 可选): 目标用户ID列表
- `group_id` (int64, 可选): 关联的群组ID

**响应**:
- `business_id` (int64): 创建的业务ID
- `timestamp` (int64): 创建时间戳

**错误码**:
- `ILLEGAL_ARGUMENT`: 参数不合法
- `DISABLED_FUNCTION`: 功能已禁用
- `RATE_LIMITED`: 请求频率过高

**示例**:
```javascript
const response = await turmsClient.customBusinessService.createCustomBusiness({
    businessName: "我的业务",
    businessData: JSON.stringify({type: "order", amount: 100}),
    targetUserIds: [123, 456]
});
```

### Update Custom Business  
更新自定义业务实例。

**请求类型**: `UPDATE_CUSTOM_BUSINESS_REQUEST`

**权限要求**: 业务创建者

**请求参数**:
- `business_id` (int64, 必填): 业务ID
- `business_name` (string, 可选): 新的业务名称
- `business_data` (string, 可选): 新的业务数据

### Query Custom Businesses
查询自定义业务实例。

**请求类型**: `QUERY_CUSTOM_BUSINESS_REQUEST`

**权限要求**: 已登录用户

**请求参数**:
- `limit` (int32, 可选): 返回结果数量限制，默认50，最大100
- `last_updated_date` (int64, 可选): 查询指定时间之后更新的业务

**响应**: 业务实例列表
```

### 配置文档
```markdown
## Custom Business 配置

### 基础配置
```yaml
turms:
  service:
    custom-business:
      enabled: true  # 是否启用自定义业务功能
      max-business-name-length: 50  # 业务名称最大长度
      max-business-data-length: 1000  # 业务数据最大长度
      allow-anonymous-access: false  # 是否允许匿名访问
      max-businesses-per-user: 100  # 每个用户最大业务数量
```

### 性能配置
```yaml
turms:
  service:
    custom-business:
      business-cache-ttl: PT30M  # 业务缓存过期时间
      rate-limit:
        enabled: true
        requests-per-minute: 10  # 每分钟最大请求数
        window-size: PT1M  # 限流窗口大小
```
```

## 🎯 开发最佳实践

### 1. 版本兼容性
- **向后兼容**: 新字段使用 `optional` 标记
- **字段编号**: 永远不要重复使用已废弃的字段编号
- **枚举扩展**: 为新的枚举值预留编号空间

### 2. 错误处理
- **统一错误码**: 使用标准的 `TurmsStatusCode`
- **清晰错误信息**: 提供有意义的错误描述
- **国际化支持**: 支持多语言错误消息

### 3. 性能优化
- **数据库索引**: 为查询字段创建适当的索引
- **缓存策略**: 对热点数据使用缓存
- **响应式编程**: 保持非阻塞的编程模式
- **分页查询**: 避免一次性返回大量数据

### 4. 安全考虑
- **权限验证**: 在每个操作中验证用户权限
- **输入验证**: 严格验证所有输入参数
- **SQL注入防护**: 使用参数化查询
- **限流保护**: 防止恶意请求和DDoS攻击

### 5. 监控和日志
- **关键操作日志**: 记录重要的业务操作
- **性能指标**: 监控响应时间和吞吐量
- **错误追踪**: 记录和分析错误信息
- **用户行为**: 分析用户使用模式

### 6. 测试策略
- **单元测试**: 覆盖核心业务逻辑
- **集成测试**: 验证组件间交互
- **API测试**: 测试完整的请求/响应流程
- **性能测试**: 验证系统在负载下的表现

## 🔄 持续改进

### 版本发布流程
1. **开发阶段**: 在 dev 分支开发新功能
2. **测试阶段**: 在 test 环境进行完整测试
3. **预发布**: 在 staging 环境验证
4. **生产发布**: 灰度发布到生产环境
5. **监控反馈**: 持续监控和优化

### 文档维护
- 及时更新 API 文档
- 维护配置说明文档
- 更新部署和运维文档
- 记录已知问题和解决方案

通过遵循这个完整的开发指南，你可以在 Turms 系统中成功添加新的业务功能，同时保持系统的一致性、可维护性和扩展性。