# ç”¨æˆ·æ ‡ç­¾ç³»ç»Ÿæ¶æ„è®¾è®¡æ–¹æ¡ˆ

## ğŸ“Š æ‰§è¡Œæ‘˜è¦

**æ ¸å¿ƒç»“è®ºï¼šå»ºè®®åˆ›å»ºç‹¬ç«‹çš„æ ‡ç­¾å­ç³»ç»Ÿ**

- **æ¶æ„ç­–ç•¥**ï¼šæ ‡ç­¾å­ç³»ç»Ÿ + ç”¨æˆ·æ¨¡å—è§£è€¦è®¾è®¡
- **å®æ–½å‘¨æœŸ**ï¼š6-8å‘¨
- **å¼€å‘æˆæœ¬**ï¼š45äººå¤© (çº¦3-4äººå›¢é˜Ÿ)
- **æŠ€æœ¯éš¾åº¦**ï¼šâ˜…â˜…â˜…â˜†â˜† (ä¸­ç­‰)
- **æ¨èåº¦**ï¼šâœ… å¼ºçƒˆæ¨è

---

## ğŸ¯ éœ€æ±‚åˆ†æ

### ä¸šåŠ¡éœ€æ±‚æ¸…å•

#### æ ¸å¿ƒåŠŸèƒ½éœ€æ±‚
- âœ… **å¤šé¢†åŸŸæ ‡ç­¾åˆ†ç±»**ï¼šæ˜Ÿåº§ã€æ€§å–å‘ã€ç”Ÿæ´»æ–¹å¼ã€å…´è¶£çˆ±å¥½ç­‰
- âœ… **è‡ªå®šä¹‰æ ‡ç­¾åŠŸèƒ½**ï¼šç”¨æˆ·å¯åˆ›å»ºä¸ªæ€§åŒ–æ ‡ç­¾
- âœ… **æ ‡ç­¾å†…å®¹ç®¡ç†**ï¼šå®¡æ ¸ã€ç¼–è¾‘ã€åˆ é™¤æ ‡ç­¾
- âœ… **ä¸ªæ€§åŒ–æ ‡ç­¾æ¨è**ï¼šåŸºäºç”¨æˆ·è¡Œä¸ºçš„æ™ºèƒ½æ¨è
- âœ… **æ ‡ç­¾äº‘å±•ç¤º**ï¼šæŒ‰çƒ­åº¦å±•ç¤ºæµè¡Œæ ‡ç­¾
- âœ… **æ ‡ç­¾ç›¸å…³å†…å®¹/ç¾¤ç»„å±•ç¤º**ï¼šå†…å®¹å‘ç°åŠŸèƒ½

#### éåŠŸèƒ½æ€§éœ€æ±‚
- **é«˜æ€§èƒ½**ï¼šæ ‡ç­¾æŸ¥è¯¢å“åº”æ—¶é—´ < 100ms
- **é«˜å¹¶å‘**ï¼šæ”¯æŒä¸‡çº§å¹¶å‘æ ‡ç­¾æ“ä½œ
- **å¯æ‰©å±•**ï¼šæ”¯æŒæ–°æ ‡ç­¾åˆ†ç±»å’Œæ¨èç®—æ³•æ‰©å±•
- **æ˜“ç»´æŠ¤**ï¼šæ¨¡å—åŒ–è®¾è®¡ï¼Œä¾¿äºåŠŸèƒ½è¿­ä»£

### ç”¨æˆ·ä»·å€¼åˆ†æ

1. **ç”¨æˆ·ç”»åƒå®Œå–„**ï¼šé€šè¿‡æ ‡ç­¾æ›´ç²¾å‡†åœ°æè¿°ç”¨æˆ·ç‰¹å¾
2. **ç¤¾äº¤åŒ¹é…ä¼˜åŒ–**ï¼šåŸºäºæ ‡ç­¾è¿›è¡Œå¥½å‹/ç¾¤ç»„æ¨è
3. **å†…å®¹ä¸ªæ€§åŒ–**ï¼šæ ¹æ®æ ‡ç­¾æ¨èç›¸å…³å†…å®¹å’Œç¾¤ç»„
4. **ç¤¾åŒºæ´»è·ƒåº¦æå‡**ï¼šæ ‡ç­¾äº‘å’Œçƒ­é—¨æ ‡ç­¾å¢åŠ ç”¨æˆ·å‚ä¸åº¦

---

## ğŸ—ï¸ æ¶æ„è®¾è®¡æ–¹æ¡ˆ

### æ€»ä½“æ¶æ„

#### æ–¹æ¡ˆAï¼šç‹¬ç«‹æ ‡ç­¾å­ç³»ç»Ÿ (æ¨è)

```
ç”¨æˆ·æ¨¡å— (User Module)
â”œâ”€â”€ åŸºç¡€ç”¨æˆ·ä¿¡æ¯
â”œâ”€â”€ ç”¨æˆ·è®¤è¯ä¸æˆæƒ
â”œâ”€â”€ ç”¨æˆ·å…³ç³»ç®¡ç†
â””â”€â”€ ç”¨æˆ·æ ‡ç­¾å…³è”æ¥å£

æ ‡ç­¾å­ç³»ç»Ÿ (Tag Subsystem)  
â”œâ”€â”€ æ ‡ç­¾ç®¡ç†æœåŠ¡ (TagService)
â”œâ”€â”€ æ ‡ç­¾åˆ†ç±»æœåŠ¡ (TagCategoryService) 
â”œâ”€â”€ ç”¨æˆ·æ ‡ç­¾å…³ç³»æœåŠ¡ (UserTagService)
â”œâ”€â”€ æ¨èå¼•æ“æœåŠ¡ (TagRecommendationService)
â”œâ”€â”€ çƒ­åº¦ç»Ÿè®¡æœåŠ¡ (TagHeatService)
â””â”€â”€ å†…å®¹å‘ç°æœåŠ¡ (TagDiscoveryService)

å…±äº«ç»„ä»¶
â”œâ”€â”€ ç¼“å­˜å±‚ (Redis)
â”œâ”€â”€ æ•°æ®åº“å±‚ (MongoDB)
â””â”€â”€ æ¶ˆæ¯é˜Ÿåˆ— (RabbitMQ/Kafka)
```

#### æ–¹æ¡ˆBï¼šç”¨æˆ·æ¨¡å—æ‰©å±• (ä¸æ¨è)

```
ç”¨æˆ·æ¨¡å— (User Module)
â”œâ”€â”€ åŸºç¡€ç”¨æˆ·ä¿¡æ¯
â”œâ”€â”€ ç”¨æˆ·è®¤è¯ä¸æˆæƒ
â”œâ”€â”€ ç”¨æˆ·å…³ç³»ç®¡ç†
â”œâ”€â”€ ç”¨æˆ·æ ‡ç­¾ç®¡ç†      // æ–°å¢
â”œâ”€â”€ æ ‡ç­¾æ¨èç³»ç»Ÿ      // æ–°å¢
â”œâ”€â”€ çƒ­åº¦ç»Ÿè®¡åŠŸèƒ½      // æ–°å¢
â””â”€â”€ å†…å®¹å‘ç°åŠŸèƒ½      // æ–°å¢
```

### é€‰æ‹©æ–¹æ¡ˆAçš„åŸå› 

1. **å•ä¸€èŒè´£åŸåˆ™**ï¼šç”¨æˆ·æ¨¡å—ä¸“æ³¨æ ¸å¿ƒç”¨æˆ·åŠŸèƒ½ï¼Œæ ‡ç­¾ç³»ç»Ÿä¸“æ³¨æ ‡ç­¾ä¸šåŠ¡
2. **æ€§èƒ½ä¼˜åŒ–ç©ºé—´**ï¼šæ ‡ç­¾ç³»ç»Ÿå¯ä»¥ç‹¬ç«‹è®¾è®¡ç¼“å­˜å’Œç´¢å¼•ç­–ç•¥
3. **å¼€å‘å¹¶è¡Œåº¦**ï¼šå›¢é˜Ÿå¯ä»¥å¹¶è¡Œå¼€å‘ç”¨æˆ·åŠŸèƒ½å’Œæ ‡ç­¾åŠŸèƒ½
4. **é£é™©éš”ç¦»**ï¼šæ ‡ç­¾ç³»ç»Ÿé—®é¢˜ä¸ä¼šå½±å“æ ¸å¿ƒç”¨æˆ·åŠŸèƒ½
5. **æ‰©å±•æ€§æ›´å¥½**ï¼šæœªæ¥å¯ä»¥ç‹¬ç«‹æ‰©å±•æ ‡ç­¾ç›¸å…³çš„AIåŠŸèƒ½

---

## ğŸ“‹ è¯¦ç»†è®¾è®¡æ–¹æ¡ˆ

### ç¬¬ä¸€é˜¶æ®µï¼šåè®®å±‚è®¾è®¡

#### 1.1 æ•°æ®æ¨¡å‹å®šä¹‰

**æ ‡ç­¾åˆ†ç±»æ¨¡å‹**
```protobuf
// proto/model/tag/tag_category.proto
message TagCategory {
    optional int64 id = 1;
    optional string name = 2;           // åˆ†ç±»åç§°ï¼šæ˜Ÿåº§ã€å…´è¶£çˆ±å¥½
    optional string description = 3;    // åˆ†ç±»æè¿°
    optional string icon = 4;           // åˆ†ç±»å›¾æ ‡
    optional string color = 5;          // åˆ†ç±»é¢œè‰²
    optional int32 sort_order = 6;      // æ’åºæƒé‡
    optional bool is_active = 7;        // æ˜¯å¦å¯ç”¨
    optional int64 created_date = 8;    // åˆ›å»ºæ—¶é—´
    repeated Value custom_attributes = 15;
}
```

**æ ‡ç­¾æ¨¡å‹**
```protobuf
// proto/model/tag/tag.proto
message Tag {
    optional int64 id = 1;
    optional string name = 2;           // æ ‡ç­¾åç§°
    optional string description = 3;    // æ ‡ç­¾æè¿°
    optional int64 category_id = 4;     // æ‰€å±åˆ†ç±»
    optional int32 heat_score = 5;      // çƒ­åº¦è¯„åˆ†
    optional bool is_system_tag = 6;    // æ˜¯å¦ç³»ç»Ÿæ ‡ç­¾
    optional bool is_verified = 7;      // æ˜¯å¦è®¤è¯æ ‡ç­¾
    optional int64 creator_id = 8;      // åˆ›å»ºè€…ID
    optional int64 created_date = 9;    // åˆ›å»ºæ—¶é—´
    optional int32 usage_count = 10;    // ä½¿ç”¨æ¬¡æ•°
    repeated Value custom_attributes = 15;
}
```

**ç”¨æˆ·æ ‡ç­¾å…³ç³»æ¨¡å‹**
```protobuf
// proto/model/tag/user_tag_relation.proto
message UserTagRelation {
    optional int64 user_id = 1;         // ç”¨æˆ·ID
    optional int64 tag_id = 2;          // æ ‡ç­¾ID
    optional int64 created_date = 3;    // å…³è”æ—¶é—´
    optional bool is_visible = 4;       // æ˜¯å¦å…¬å¼€æ˜¾ç¤º
    optional int32 priority = 5;        // æ˜¾ç¤ºä¼˜å…ˆçº§
    optional string source = 6;         // æ¥æºï¼šç”¨æˆ·æ·»åŠ /ç³»ç»Ÿæ¨è
    repeated Value custom_attributes = 15;
}
```

#### 1.2 è¯·æ±‚åè®®å®šä¹‰

**æ ‡ç­¾ç®¡ç†è¯·æ±‚**
```protobuf
// proto/request/tag/create_tag_request.proto
message CreateTagRequest {
    string name = 1;
    optional string description = 2;
    int64 category_id = 3;
    optional bool is_visible = 4;
    repeated Value custom_attributes = 15;
}

// proto/request/tag/query_tags_request.proto
message QueryTagsRequest {
    optional int64 category_id = 1;
    optional string keyword = 2;
    optional TagSortType sort_type = 3;
    optional int32 offset = 4;
    optional int32 limit = 5;
    repeated Value custom_attributes = 15;
}

// proto/request/tag/query_tag_cloud_request.proto
message QueryTagCloudRequest {
    optional int64 category_id = 1;
    optional int32 limit = 2;
    optional TagCloudType cloud_type = 3;  // çƒ­åº¦/æœ€æ–°/æ¨è
    repeated Value custom_attributes = 15;
}
```

**ç”¨æˆ·æ ‡ç­¾æ“ä½œè¯·æ±‚**
```protobuf
// proto/request/tag/add_user_tag_request.proto
message AddUserTagRequest {
    int64 user_id = 1;
    int64 tag_id = 2;
    optional bool is_visible = 3;
    optional int32 priority = 4;
    repeated Value custom_attributes = 15;
}

// proto/request/tag/query_user_tags_request.proto
message QueryUserTagsRequest {
    int64 user_id = 1;
    optional bool visible_only = 2;
    optional int64 category_id = 3;
    repeated Value custom_attributes = 15;
}

// proto/request/tag/get_tag_recommendations_request.proto
message GetTagRecommendationsRequest {
    int64 user_id = 1;
    optional int64 category_id = 2;
    optional int32 limit = 3;
    optional RecommendationType type = 4;  // ååŒè¿‡æ»¤/å†…å®¹æ¨è/çƒ­é—¨æ¨è
    repeated Value custom_attributes = 15;
}
```

#### 1.3 æšä¸¾ç±»å‹å®šä¹‰

```protobuf
// proto/constant/tag_sort_type.proto
enum TagSortType {
    HEAT_DESC = 0;      // æŒ‰çƒ­åº¦é™åº
    USAGE_DESC = 1;     // æŒ‰ä½¿ç”¨æ¬¡æ•°é™åº
    CREATE_TIME_DESC = 2; // æŒ‰åˆ›å»ºæ—¶é—´é™åº
    NAME_ASC = 3;       // æŒ‰åç§°å‡åº
}

// proto/constant/tag_cloud_type.proto
enum TagCloudType {
    HOT_TAGS = 0;       // çƒ­é—¨æ ‡ç­¾
    RECENT_TAGS = 1;    // æœ€æ–°æ ‡ç­¾
    RECOMMENDED_TAGS = 2; // æ¨èæ ‡ç­¾
}

// proto/constant/recommendation_type.proto
enum RecommendationType {
    COLLABORATIVE_FILTERING = 0;  // ååŒè¿‡æ»¤
    CONTENT_BASED = 1;           // åŸºäºå†…å®¹
    POPULAR_TAGS = 2;            // çƒ­é—¨æ ‡ç­¾
    MIXED_STRATEGY = 3;          // æ··åˆç­–ç•¥
}
```

#### 1.4 æ›´æ–°TurmsRequeståè®®

```protobuf
// proto/request/turms_request.proto
oneof kind {
    // ç°æœ‰è¯·æ±‚...
    
    // Tag Management
    CreateTagRequest create_tag_request = 220;
    QueryTagsRequest query_tags_request = 221;
    QueryTagCloudRequest query_tag_cloud_request = 222;
    
    // User Tag Operations
    AddUserTagRequest add_user_tag_request = 230;
    QueryUserTagsRequest query_user_tags_request = 231;
    GetTagRecommendationsRequest get_tag_recommendations_request = 232;
}
```

### ç¬¬äºŒé˜¶æ®µï¼šæ•°æ®å±‚è®¾è®¡

#### 2.1 å®ä½“ç±»è®¾è®¡

**æ ‡ç­¾åˆ†ç±»å®ä½“**
```java
@Document(TagCategory.COLLECTION_NAME)
public final class TagCategory extends BaseEntity {
    public static final String COLLECTION_NAME = "tagCategory";
    
    private final Long id;
    private final String name;
    private final String description;
    private final String icon;
    private final String color;
    private final Integer sortOrder;
    private final Boolean isActive;
    private final Date creationDate;
    
    public static class Fields {
        public static final String ID = "_id";
        public static final String NAME = "name";
        public static final String DESCRIPTION = "description";
        public static final String ICON = "icon";
        public static final String COLOR = "color";
        public static final String SORT_ORDER = "sortOrder";
        public static final String IS_ACTIVE = "isActive";
        public static final String CREATION_DATE = "creationDate";
    }
    
    // æ„é€ å‡½æ•°ã€getteræ–¹æ³•...
}
```

**æ ‡ç­¾å®ä½“**
```java
@Document(Tag.COLLECTION_NAME)
public final class Tag extends BaseEntity {
    public static final String COLLECTION_NAME = "tag";
    
    private final Long id;
    private final String name;
    private final String description;
    private final Long categoryId;
    private final Integer heatScore;
    private final Boolean isSystemTag;
    private final Boolean isVerified;
    private final Long creatorId;
    private final Date creationDate;
    private final Integer usageCount;
    
    public static class Fields {
        public static final String ID = "_id";
        public static final String NAME = "name";
        public static final String DESCRIPTION = "description";
        public static final String CATEGORY_ID = "categoryId";
        public static final String HEAT_SCORE = "heatScore";
        public static final String IS_SYSTEM_TAG = "isSystemTag";
        public static final String IS_VERIFIED = "isVerified";
        public static final String CREATOR_ID = "creatorId";
        public static final String CREATION_DATE = "creationDate";
        public static final String USAGE_COUNT = "usageCount";
    }
    
    // æ„é€ å‡½æ•°ã€getteræ–¹æ³•...
}
```

**ç”¨æˆ·æ ‡ç­¾å…³ç³»å®ä½“**
```java
@Document(UserTagRelation.COLLECTION_NAME)
public final class UserTagRelation extends BaseEntity {
    public static final String COLLECTION_NAME = "userTagRelation";
    
    private final Long userId;
    private final Long tagId;
    private final Date creationDate;
    private final Boolean isVisible;
    private final Integer priority;
    private final String source;
    
    public static class Fields {
        public static final String USER_ID = "userId";
        public static final String TAG_ID = "tagId";
        public static final String CREATION_DATE = "creationDate";
        public static final String IS_VISIBLE = "isVisible";
        public static final String PRIORITY = "priority";
        public static final String SOURCE = "source";
    }
    
    // æ„é€ å‡½æ•°ã€getteræ–¹æ³•...
}
```

#### 2.2 Repositoryå±‚è®¾è®¡

**æ ‡ç­¾åˆ†ç±»Repository**
```java
@Repository
public class TagCategoryRepository extends BaseRepository<TagCategory, Long> {
    
    public TagCategoryRepository(@Qualifier("userMongoClient") TurmsMongoClient mongoClient) {
        super(mongoClient, TagCategory.class);
    }
    
    public Flux<TagCategory> findActiveCategories() {
        Filter filter = Filter.newBuilder(1)
                .eq(TagCategory.Fields.IS_ACTIVE, true);
        return mongoClient.findMany(entityClass, filter)
                .sort(TagCategory.Fields.SORT_ORDER);
    }
    
    public Mono<TagCategory> findByName(String name) {
        Filter filter = Filter.newBuilder(1)
                .eq(TagCategory.Fields.NAME, name);
        return mongoClient.findOne(entityClass, filter);
    }
}
```

**æ ‡ç­¾Repository**
```java
@Repository
public class TagRepository extends BaseRepository<Tag, Long> {
    
    public TagRepository(@Qualifier("userMongoClient") TurmsMongoClient mongoClient) {
        super(mongoClient, Tag.class);
    }
    
    public Flux<Tag> findByCategory(Long categoryId, TagSortType sortType, Integer limit) {
        Filter filter = Filter.newBuilder(1)
                .eq(Tag.Fields.CATEGORY_ID, categoryId);
        
        String sortField = switch (sortType) {
            case HEAT_DESC -> Tag.Fields.HEAT_SCORE;
            case USAGE_DESC -> Tag.Fields.USAGE_COUNT;
            case CREATE_TIME_DESC -> Tag.Fields.CREATION_DATE;
            case NAME_ASC -> Tag.Fields.NAME;
        };
        
        return mongoClient.findMany(entityClass, filter)
                .sort(sortField, sortType == TagSortType.NAME_ASC ? 1 : -1)
                .limit(limit);
    }
    
    public Flux<Tag> searchByName(String keyword, Integer limit) {
        Filter filter = Filter.newBuilder(1)
                .regex(Tag.Fields.NAME, ".*" + keyword + ".*", "i");
        return mongoClient.findMany(entityClass, filter)
                .sort(Tag.Fields.HEAT_SCORE, -1)
                .limit(limit);
    }
    
    public Mono<Boolean> incrementUsageCount(Long tagId) {
        Filter filter = Filter.newBuilder(1)
                .eq(Tag.Fields.ID, tagId);
        Update update = Update.newBuilder(1)
                .inc(Tag.Fields.USAGE_COUNT, 1);
        return mongoClient.updateOne(entityClass, filter, update)
                .map(result -> result.getModifiedCount() > 0);
    }
    
    public Flux<Tag> findHotTags(Long categoryId, Integer limit) {
        FilterBuilder filterBuilder = Filter.newBuilder(2);
        if (categoryId != null) {
            filterBuilder.eq(Tag.Fields.CATEGORY_ID, categoryId);
        }
        filterBuilder.gt(Tag.Fields.HEAT_SCORE, 0);
        
        return mongoClient.findMany(entityClass, filterBuilder.build())
                .sort(Tag.Fields.HEAT_SCORE, -1)
                .limit(limit);
    }
}
```

**ç”¨æˆ·æ ‡ç­¾å…³ç³»Repository**
```java
@Repository
public class UserTagRelationRepository extends BaseRepository<UserTagRelation, String> {
    
    public UserTagRelationRepository(@Qualifier("userMongoClient") TurmsMongoClient mongoClient) {
        super(mongoClient, UserTagRelation.class);
    }
    
    public Flux<UserTagRelation> findByUserId(Long userId, Boolean visibleOnly) {
        FilterBuilder filterBuilder = Filter.newBuilder(2)
                .eq(UserTagRelation.Fields.USER_ID, userId);
        if (visibleOnly != null && visibleOnly) {
            filterBuilder.eq(UserTagRelation.Fields.IS_VISIBLE, true);
        }
        
        return mongoClient.findMany(entityClass, filterBuilder.build())
                .sort(UserTagRelation.Fields.PRIORITY, -1);
    }
    
    public Flux<UserTagRelation> findByTagId(Long tagId) {
        Filter filter = Filter.newBuilder(1)
                .eq(UserTagRelation.Fields.TAG_ID, tagId);
        return mongoClient.findMany(entityClass, filter);
    }
    
    public Mono<Boolean> existsByUserIdAndTagId(Long userId, Long tagId) {
        Filter filter = Filter.newBuilder(2)
                .eq(UserTagRelation.Fields.USER_ID, userId)
                .eq(UserTagRelation.Fields.TAG_ID, tagId);
        return mongoClient.exists(entityClass, filter);
    }
    
    public Mono<Boolean> deleteByUserIdAndTagId(Long userId, Long tagId) {
        Filter filter = Filter.newBuilder(2)
                .eq(UserTagRelation.Fields.USER_ID, userId)
                .eq(UserTagRelation.Fields.TAG_ID, tagId);
        return mongoClient.deleteOne(entityClass, filter)
                .map(result -> result.getDeletedCount() > 0);
    }
    
    public Mono<Long> countByTagId(Long tagId) {
        Filter filter = Filter.newBuilder(1)
                .eq(UserTagRelation.Fields.TAG_ID, tagId);
        return mongoClient.count(entityClass, filter);
    }
}
```

#### 2.3 æ•°æ®åº“ç´¢å¼•ç­–ç•¥

```javascript
// MongoDBç´¢å¼•åˆ›å»ºè„šæœ¬

// æ ‡ç­¾åˆ†ç±»ç´¢å¼•
db.tagCategory.createIndex({"isActive": 1, "sortOrder": 1});
db.tagCategory.createIndex({"name": 1}, {unique: true});

// æ ‡ç­¾ç´¢å¼•
db.tag.createIndex({"categoryId": 1, "heatScore": -1});     // åˆ†ç±»æŸ¥è¯¢+çƒ­åº¦æ’åº
db.tag.createIndex({"name": "text", "description": "text"}); // å…¨æ–‡æœç´¢
db.tag.createIndex({"isSystemTag": 1, "heatScore": -1});    // ç³»ç»Ÿæ ‡ç­¾çƒ­åº¦
db.tag.createIndex({"creatorId": 1, "creationDate": -1});   // åˆ›å»ºè€…æŸ¥è¯¢
db.tag.createIndex({"usageCount": -1});                     // ä½¿ç”¨æ¬¡æ•°æ’åº
db.tag.createIndex({"name": 1}, {unique: true});            // æ ‡ç­¾åå”¯ä¸€

// ç”¨æˆ·æ ‡ç­¾å…³ç³»ç´¢å¼•
db.userTagRelation.createIndex({"userId": 1, "isVisible": 1, "priority": -1}); // ç”¨æˆ·æ ‡ç­¾æŸ¥è¯¢
db.userTagRelation.createIndex({"tagId": 1});                                  // æ ‡ç­¾ç”¨æˆ·ç»Ÿè®¡
db.userTagRelation.createIndex({"userId": 1, "tagId": 1}, {unique: true});     // å”¯ä¸€çº¦æŸ
db.userTagRelation.createIndex({"creationDate": -1});                          // æ—¶é—´åºåˆ—æŸ¥è¯¢
db.userTagRelation.createIndex({"source": 1, "creationDate": -1});             // æ¥æºç»Ÿè®¡

// TTLç´¢å¼•ï¼ˆå¦‚æœéœ€è¦ï¼‰
db.userTagRelation.createIndex({"creationDate": 1}, {expireAfterSeconds: 31536000}); // 1å¹´è¿‡æœŸ
```

### ç¬¬ä¸‰é˜¶æ®µï¼šä¸šåŠ¡é€»è¾‘å®ç°

#### 3.1 æœåŠ¡å±‚æ¶æ„

**æ ‡ç­¾åˆ†ç±»æœåŠ¡**
```java
@Service
public class TagCategoryService {
    
    private final TagCategoryRepository tagCategoryRepository;
    
    public TagCategoryService(TagCategoryRepository tagCategoryRepository) {
        this.tagCategoryRepository = tagCategoryRepository;
    }
    
    public Mono<TagCategory> createCategory(String name, String description, 
                                          String icon, String color, Integer sortOrder) {
        return tagCategoryRepository.findByName(name)
            .hasElement()
            .flatMap(exists -> {
                if (exists) {
                    return Mono.error(ResponseException.get(
                        ResponseStatusCode.TAG_CATEGORY_ALREADY_EXISTS,
                        "æ ‡ç­¾åˆ†ç±»å·²å­˜åœ¨"
                    ));
                }
                
                TagCategory category = new TagCategory(
                    null, name, description, icon, color, 
                    sortOrder, true, new Date()
                );
                return tagCategoryRepository.insert(category);
            });
    }
    
    public Flux<TagCategory> getActiveCategories() {
        return tagCategoryRepository.findActiveCategories();
    }
    
    public Mono<Boolean> updateCategory(Long categoryId, String name, String description,
                                      String icon, String color, Integer sortOrder) {
        Filter filter = Filter.newBuilder(1).eq("_id", categoryId);
        Update update = Update.newBuilder(5);
        
        if (name != null) update.set(TagCategory.Fields.NAME, name);
        if (description != null) update.set(TagCategory.Fields.DESCRIPTION, description);
        if (icon != null) update.set(TagCategory.Fields.ICON, icon);
        if (color != null) update.set(TagCategory.Fields.COLOR, color);
        if (sortOrder != null) update.set(TagCategory.Fields.SORT_ORDER, sortOrder);
        
        return tagCategoryRepository.updateOne(filter, update)
            .map(result -> result.getModifiedCount() > 0);
    }
}
```

**æ ‡ç­¾ç®¡ç†æœåŠ¡**
```java
@Service
public class TagService {
    
    private final TagRepository tagRepository;
    private final UserTagRelationRepository userTagRelationRepository;
    private final TurmsRedisClient redisClient;
    
    public TagService(TagRepository tagRepository, 
                     UserTagRelationRepository userTagRelationRepository,
                     TurmsRedisClient redisClient) {
        this.tagRepository = tagRepository;
        this.userTagRelationRepository = userTagRelationRepository;
        this.redisClient = redisClient;
    }
    
    public Mono<Tag> createTag(String name, String description, Long categoryId, 
                              Boolean isSystemTag, Long creatorId) {
        return validateTagName(name)
            .then(tagRepository.findByName(name))
            .hasElement()
            .flatMap(exists -> {
                if (exists) {
                    return Mono.error(ResponseException.get(
                        ResponseStatusCode.TAG_ALREADY_EXISTS,
                        "æ ‡ç­¾å·²å­˜åœ¨"
                    ));
                }
                
                Tag tag = new Tag(
                    null, name, description, categoryId, 0,
                    isSystemTag != null ? isSystemTag : false,
                    false, creatorId, new Date(), 0
                );
                return tagRepository.insert(tag);
            });
    }
    
    public Flux<Tag> queryTags(Long categoryId, String keyword, TagSortType sortType, 
                              Integer offset, Integer limit) {
        if (keyword != null && !keyword.trim().isEmpty()) {
            return tagRepository.searchByName(keyword.trim(), limit);
        }
        
        if (categoryId != null) {
            return tagRepository.findByCategory(categoryId, sortType, limit);
        }
        
        return tagRepository.findHotTags(null, limit);
    }
    
    public Mono<Boolean> deleteTag(Long tagId, Long operatorId) {
        return tagRepository.findById(tagId)
            .switchIfEmpty(Mono.error(ResponseException.get(
                ResponseStatusCode.TAG_NOT_FOUND, "æ ‡ç­¾ä¸å­˜åœ¨")))
            .flatMap(tag -> {
                // æ£€æŸ¥æ˜¯å¦ä¸ºç³»ç»Ÿæ ‡ç­¾
                if (tag.getIsSystemTag() && !isAdmin(operatorId)) {
                    return Mono.error(ResponseException.get(
                        ResponseStatusCode.INSUFFICIENT_PERMISSION,
                        "æ— æƒåˆ é™¤ç³»ç»Ÿæ ‡ç­¾"
                    ));
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰ç”¨æˆ·ä½¿ç”¨è¯¥æ ‡ç­¾
                return userTagRelationRepository.countByTagId(tagId)
                    .flatMap(count -> {
                        if (count > 0) {
                            return Mono.error(ResponseException.get(
                                ResponseStatusCode.TAG_IN_USE,
                                "æ ‡ç­¾æ­£åœ¨ä½¿ç”¨ä¸­ï¼Œæ— æ³•åˆ é™¤"
                            ));
                        }
                        return tagRepository.deleteById(tagId);
                    });
            });
    }
    
    public Mono<Boolean> incrementTagHeat(Long tagId, Integer increment) {
        Filter filter = Filter.newBuilder(1).eq("_id", tagId);
        Update update = Update.newBuilder(1)
            .inc(Tag.Fields.HEAT_SCORE, increment);
        
        return tagRepository.updateOne(filter, update)
            .map(result -> result.getModifiedCount() > 0)
            .doOnSuccess(success -> {
                if (success) {
                    // å¼‚æ­¥æ›´æ–°ç¼“å­˜
                    updateTagHeatCache(tagId, increment);
                }
            });
    }
    
    private Mono<Void> validateTagName(String name) {
        if (name == null || name.trim().isEmpty()) {
            return Mono.error(ResponseException.get(
                ResponseStatusCode.INVALID_TAG_NAME, "æ ‡ç­¾åä¸èƒ½ä¸ºç©º"));
        }
        if (name.length() > 20) {
            return Mono.error(ResponseException.get(
                ResponseStatusCode.INVALID_TAG_NAME, "æ ‡ç­¾åé•¿åº¦ä¸èƒ½è¶…è¿‡20ä¸ªå­—ç¬¦"));
        }
        if (containsInvalidCharacters(name)) {
            return Mono.error(ResponseException.get(
                ResponseStatusCode.INVALID_TAG_NAME, "æ ‡ç­¾ååŒ…å«éæ³•å­—ç¬¦"));
        }
        return Mono.empty();
    }
    
    private void updateTagHeatCache(Long tagId, Integer increment) {
        String cacheKey = "tag:heat:" + tagId;
        redisClient.incr(cacheKey, increment);
    }
}
```

**ç”¨æˆ·æ ‡ç­¾å…³ç³»æœåŠ¡**
```java
@Service
public class UserTagService {
    
    private final UserTagRelationRepository userTagRelationRepository;
    private final TagRepository tagRepository;
    private final TagService tagService;
    
    public UserTagService(UserTagRelationRepository userTagRelationRepository,
                         TagRepository tagRepository,
                         TagService tagService) {
        this.userTagRelationRepository = userTagRelationRepository;
        this.tagRepository = tagRepository;
        this.tagService = tagService;
    }
    
    public Mono<Void> addUserTag(Long userId, Long tagId, Boolean isVisible, 
                                Integer priority, String source) {
        return userTagRelationRepository.existsByUserIdAndTagId(userId, tagId)
            .flatMap(exists -> {
                if (exists) {
                    return Mono.error(ResponseException.get(
                        ResponseStatusCode.USER_TAG_ALREADY_EXISTS,
                        "ç”¨æˆ·å·²æ·»åŠ è¯¥æ ‡ç­¾"
                    ));
                }
                
                // æ£€æŸ¥æ ‡ç­¾æ˜¯å¦å­˜åœ¨
                return tagRepository.existsById(tagId)
                    .flatMap(tagExists -> {
                        if (!tagExists) {
                            return Mono.error(ResponseException.get(
                                ResponseStatusCode.TAG_NOT_FOUND, "æ ‡ç­¾ä¸å­˜åœ¨"));
                        }
                        
                        UserTagRelation relation = new UserTagRelation(
                            userId, tagId, new Date(),
                            isVisible != null ? isVisible : true,
                            priority != null ? priority : 0,
                            source != null ? source : "USER_ADDED"
                        );
                        
                        return userTagRelationRepository.insert(relation)
                            .then(tagService.incrementTagHeat(tagId, 1))
                            .then();
                    });
            });
    }
    
    public Flux<Tag> getUserTags(Long userId, Boolean visibleOnly, Long categoryId) {
        return userTagRelationRepository.findByUserId(userId, visibleOnly)
            .map(UserTagRelation::getTagId)
            .collectList()
            .flatMapMany(tagIds -> {
                if (tagIds.isEmpty()) {
                    return Flux.empty();
                }
                
                FilterBuilder filterBuilder = Filter.newBuilder(2)
                    .in(Tag.Fields.ID, tagIds);
                if (categoryId != null) {
                    filterBuilder.eq(Tag.Fields.CATEGORY_ID, categoryId);
                }
                
                return tagRepository.findMany(filterBuilder.build());
            });
    }
    
    public Mono<Boolean> removeUserTag(Long userId, Long tagId) {
        return userTagRelationRepository.deleteByUserIdAndTagId(userId, tagId)
            .doOnSuccess(success -> {
                if (success) {
                    // å¼‚æ­¥å‡å°‘æ ‡ç­¾çƒ­åº¦
                    tagService.incrementTagHeat(tagId, -1).subscribe();
                }
            });
    }
    
    public Mono<Integer> getUserTagCount(Long userId, Boolean visibleOnly) {
        return userTagRelationRepository.findByUserId(userId, visibleOnly)
            .count()
            .cast(Integer.class);
    }
    
    public Mono<Boolean> updateUserTagVisibility(Long userId, Long tagId, Boolean isVisible) {
        Filter filter = Filter.newBuilder(2)
            .eq(UserTagRelation.Fields.USER_ID, userId)
            .eq(UserTagRelation.Fields.TAG_ID, tagId);
        Update update = Update.newBuilder(1)
            .set(UserTagRelation.Fields.IS_VISIBLE, isVisible);
        
        return userTagRelationRepository.updateOne(filter, update)
            .map(result -> result.getModifiedCount() > 0);
    }
}
```

#### 3.2 æ¨èç®—æ³•æœåŠ¡

**æ ‡ç­¾æ¨èå¼•æ“**
```java
@Service
public class TagRecommendationService {
    
    private final UserTagRelationRepository userTagRelationRepository;
    private final TagRepository tagRepository;
    private final TurmsRedisClient redisClient;
    
    public TagRecommendationService(UserTagRelationRepository userTagRelationRepository,
                                   TagRepository tagRepository,
                                   TurmsRedisClient redisClient) {
        this.userTagRelationRepository = userTagRelationRepository;
        this.tagRepository = tagRepository;
        this.redisClient = redisClient;
    }
    
    public Flux<Tag> recommendTagsForUser(Long userId, Long categoryId, 
                                         Integer limit, RecommendationType type) {
        return switch (type) {
            case COLLABORATIVE_FILTERING -> collaborativeFiltering(userId, categoryId, limit);
            case CONTENT_BASED -> contentBasedRecommendation(userId, categoryId, limit);
            case POPULAR_TAGS -> popularTagsRecommendation(categoryId, limit);
            case MIXED_STRATEGY -> mixedStrategyRecommendation(userId, categoryId, limit);
        };
    }
    
    /**
     * ååŒè¿‡æ»¤æ¨èï¼šåŸºäºç›¸ä¼¼ç”¨æˆ·çš„æ ‡ç­¾åå¥½
     */
    private Flux<Tag> collaborativeFiltering(Long userId, Long categoryId, Integer limit) {
        return getUserTags(userId)
            .collectList()
            .flatMapMany(userTags -> {
                if (userTags.isEmpty()) {
                    return popularTagsRecommendation(categoryId, limit);
                }
                
                Set<Long> userTagIds = userTags.stream()
                    .map(UserTagRelation::getTagId)
                    .collect(Collectors.toSet());
                
                // æ‰¾åˆ°æœ‰ç›¸åŒæ ‡ç­¾çš„å…¶ä»–ç”¨æˆ·
                return Flux.fromIterable(userTagIds)
                    .flatMap(userTagRelationRepository::findByTagId)
                    .filter(relation -> !relation.getUserId().equals(userId))
                    .map(UserTagRelation::getUserId)
                    .distinct()
                    .take(100) // é™åˆ¶ç›¸ä¼¼ç”¨æˆ·æ•°é‡
                    .flatMap(this::getUserTags)
                    .map(UserTagRelation::getTagId)
                    .filter(tagId -> !userTagIds.contains(tagId))
                    .groupBy(tagId -> tagId)
                    .flatMap(group -> group.count().map(count -> 
                        new TagScore(group.key(), count.intValue())))
                    .sort((a, b) -> b.getScore().compareTo(a.getScore()))
                    .take(limit)
                    .flatMap(score -> tagRepository.findById(score.getTagId()))
                    .filter(tag -> categoryId == null || tag.getCategoryId().equals(categoryId));
            });
    }
    
    /**
     * åŸºäºå†…å®¹çš„æ¨èï¼šåŸºäºç”¨æˆ·å·²æœ‰æ ‡ç­¾çš„åŒç±»åˆ«æ¨è
     */
    private Flux<Tag> contentBasedRecommendation(Long userId, Long categoryId, Integer limit) {
        return getUserTags(userId)
            .map(UserTagRelation::getTagId)
            .collectList()
            .flatMapMany(userTagIds -> {
                if (userTagIds.isEmpty()) {
                    return popularTagsRecommendation(categoryId, limit);
                }
                
                return tagRepository.findByIds(userTagIds)
                    .map(Tag::getCategoryId)
                    .distinct()
                    .flatMap(catId -> tagRepository.findByCategory(
                        categoryId != null ? categoryId : catId, 
                        TagSortType.HEAT_DESC, limit * 2))
                    .filter(tag -> !userTagIds.contains(tag.getId()))
                    .distinct()
                    .take(limit);
            });
    }
    
    /**
     * çƒ­é—¨æ ‡ç­¾æ¨èï¼šåŸºäºå…¨å±€çƒ­åº¦
     */
    private Flux<Tag> popularTagsRecommendation(Long categoryId, Integer limit) {
        return tagRepository.findHotTags(categoryId, limit);
    }
    
    /**
     * æ··åˆç­–ç•¥æ¨èï¼šç»“åˆå¤šç§ç®—æ³•
     */
    private Flux<Tag> mixedStrategyRecommendation(Long userId, Long categoryId, Integer limit) {
        int collaborativeLimit = limit / 2;
        int contentLimit = limit - collaborativeLimit;
        
        Flux<Tag> collaborativeTags = collaborativeFiltering(userId, categoryId, collaborativeLimit);
        Flux<Tag> contentTags = contentBasedRecommendation(userId, categoryId, contentLimit);
        
        return Flux.merge(collaborativeTags, contentTags)
            .distinct()
            .take(limit);
    }
    
    private Flux<UserTagRelation> getUserTags(Long userId) {
        return userTagRelationRepository.findByUserId(userId, true);
    }
    
    /**
     * æ ‡ç­¾è¯„åˆ†è¾…åŠ©ç±»
     */
    private static class TagScore {
        private final Long tagId;
        private final Integer score;
        
        public TagScore(Long tagId, Integer score) {
            this.tagId = tagId;
            this.score = score;
        }
        
        public Long getTagId() { return tagId; }
        public Integer getScore() { return score; }
    }
}
```

#### 3.3 çƒ­åº¦ç»Ÿè®¡æœåŠ¡

**æ ‡ç­¾çƒ­åº¦æœåŠ¡**
```java
@Service
public class TagHeatService {
    
    private final TagRepository tagRepository;
    private final UserTagRelationRepository userTagRelationRepository;
    private final TurmsRedisClient redisClient;
    
    public TagHeatService(TagRepository tagRepository,
                         UserTagRelationRepository userTagRelationRepository,
                         TurmsRedisClient redisClient) {
        this.tagRepository = tagRepository;
        this.userTagRelationRepository = userTagRelationRepository;
        this.redisClient = redisClient;
    }
    
    public Flux<TagCloud> getTagCloud(Long categoryId, Integer limit, TagCloudType cloudType) {
        return switch (cloudType) {
            case HOT_TAGS -> getHotTagCloud(categoryId, limit);
            case RECENT_TAGS -> getRecentTagCloud(categoryId, limit);
            case RECOMMENDED_TAGS -> getRecommendedTagCloud(categoryId, limit);
        };
    }
    
    private Flux<TagCloud> getHotTagCloud(Long categoryId, Integer limit) {
        return tagRepository.findHotTags(categoryId, limit)
            .flatMap(tag -> 
                userTagRelationRepository.countByTagId(tag.getId())
                    .map(count -> new TagCloud(tag, count.intValue(), calculateFontSize(tag.getHeatScore())))
            );
    }
    
    private Flux<TagCloud> getRecentTagCloud(Long categoryId, Integer limit) {
        FilterBuilder filterBuilder = Filter.newBuilder(2);
        if (categoryId != null) {
            filterBuilder.eq(Tag.Fields.CATEGORY_ID, categoryId);
        }
        // æœ€è¿‘30å¤©åˆ›å»ºçš„æ ‡ç­¾
        Date thirtyDaysAgo = new Date(System.currentTimeMillis() - 30L * 24 * 60 * 60 * 1000);
        filterBuilder.gte(Tag.Fields.CREATION_DATE, thirtyDaysAgo);
        
        return tagRepository.findMany(filterBuilder.build())
            .sort(Tag.Fields.CREATION_DATE, -1)
            .take(limit)
            .flatMap(tag -> 
                userTagRelationRepository.countByTagId(tag.getId())
                    .map(count -> new TagCloud(tag, count.intValue(), calculateFontSize(tag.getHeatScore())))
            );
    }
    
    private Flux<TagCloud> getRecommendedTagCloud(Long categoryId, Integer limit) {
        // åŸºäºç®—æ³•æ¨èçš„æ ‡ç­¾äº‘ï¼ˆè¿™é‡Œç®€åŒ–ä¸ºçƒ­é—¨æ ‡ç­¾ï¼‰
        return getHotTagCloud(categoryId, limit);
    }
    
    public Mono<Void> updateTagHeatBatch(Map<Long, Integer> tagHeatMap) {
        return Flux.fromIterable(tagHeatMap.entrySet())
            .flatMap(entry -> {
                Filter filter = Filter.newBuilder(1).eq("_id", entry.getKey());
                Update update = Update.newBuilder(1)
                    .inc(Tag.Fields.HEAT_SCORE, entry.getValue());
                return tagRepository.updateOne(filter, update);
            })
            .then();
    }
    
    public Mono<Map<Long, Integer>> getTagHeatMap(List<Long> tagIds) {
        return Flux.fromIterable(tagIds)
            .flatMap(tagId -> 
                tagRepository.findById(tagId)
                    .map(tag -> Map.entry(tagId, tag.getHeatScore()))
            )
            .collectMap(Map.Entry::getKey, Map.Entry::getValue);
    }
    
    private Integer calculateFontSize(Integer heatScore) {
        // æ ¹æ®çƒ­åº¦è®¡ç®—å­—ä½“å¤§å° (12-24px)
        int minSize = 12;
        int maxSize = 24;
        int maxHeat = 1000; // å‡è®¾æœ€å¤§çƒ­åº¦ä¸º1000
        
        int size = minSize + (heatScore * (maxSize - minSize)) / maxHeat;
        return Math.min(Math.max(size, minSize), maxSize);
    }
    
    /**
     * æ ‡ç­¾äº‘æ•°æ®æ¨¡å‹
     */
    public static class TagCloud {
        private final Tag tag;
        private final Integer userCount;
        private final Integer fontSize;
        
        public TagCloud(Tag tag, Integer userCount, Integer fontSize) {
            this.tag = tag;
            this.userCount = userCount;
            this.fontSize = fontSize;
        }
        
        // getter methods...
    }
}
```

### ç¬¬å››é˜¶æ®µï¼šæ¥å£å±‚å¼€å‘

#### 4.1 REST APIå®ç°

**æ ‡ç­¾ç®¡ç†æ§åˆ¶å™¨**
```java
@RestController("tags")
public class TagController extends BaseController {
    
    private final TagService tagService;
    private final TagCategoryService tagCategoryService;
    private final TagHeatService tagHeatService;
    
    public TagController(TagService tagService,
                        TagCategoryService tagCategoryService,
                        TagHeatService tagHeatService) {
        this.tagService = tagService;
        this.tagCategoryService = tagCategoryService;
        this.tagHeatService = tagHeatService;
    }
    
    @PostMapping
    @RequiredPermission(TAG_CREATE)
    public Mono<HttpHandlerResult<ResponseDTO<Tag>>> createTag(
            @RequestBody CreateTagDTO createTagDTO) {
        return tagService.createTag(
            createTagDTO.name(),
            createTagDTO.description(),
            createTagDTO.categoryId(),
            createTagDTO.isSystemTag(),
            getCurrentUserId()
        ).map(HttpHandlerResult::okIfTruthy);
    }
    
    @GetMapping
    public Mono<HttpHandlerResult<ResponseDTO<List<Tag>>>> queryTags(
            @QueryParam("categoryId") Long categoryId,
            @QueryParam("keyword") String keyword,
            @QueryParam("sortType") TagSortType sortType,
            @QueryParam("offset") Integer offset,
            @QueryParam("limit") Integer limit) {
        
        limit = getPageSize(limit);
        sortType = sortType != null ? sortType : TagSortType.HEAT_DESC;
        
        return tagService.queryTags(categoryId, keyword, sortType, offset, limit)
            .collectList()
            .map(HttpHandlerResult::okIfTruthy);
    }
    
    @GetMapping("cloud")
    public Mono<HttpHandlerResult<ResponseDTO<List<TagHeatService.TagCloud>>>> getTagCloud(
            @QueryParam("categoryId") Long categoryId,
            @QueryParam("limit") Integer limit,
            @QueryParam("cloudType") TagCloudType cloudType) {
        
        limit = limit != null ? limit : 50;
        cloudType = cloudType != null ? cloudType : TagCloudType.HOT_TAGS;
        
        return tagHeatService.getTagCloud(categoryId, limit, cloudType)
            .collectList()
            .map(HttpHandlerResult::okIfTruthy);
    }
    
    @DeleteMapping("{tagId}")
    @RequiredPermission(TAG_DELETE)
    public Mono<HttpHandlerResult<ResponseDTO<Boolean>>> deleteTag(
            @PathVariable Long tagId) {
        return tagService.deleteTag(tagId, getCurrentUserId())
            .map(HttpHandlerResult::okIfTruthy);
    }
    
    @GetMapping("categories")
    public Mono<HttpHandlerResult<ResponseDTO<List<TagCategory>>>> getCategories() {
        return tagCategoryService.getActiveCategories()
            .collectList()
            .map(HttpHandlerResult::okIfTruthy);
    }
    
    @PostMapping("categories")
    @RequiredPermission(TAG_CATEGORY_CREATE)
    public Mono<HttpHandlerResult<ResponseDTO<TagCategory>>> createCategory(
            @RequestBody CreateTagCategoryDTO createCategoryDTO) {
        return tagCategoryService.createCategory(
            createCategoryDTO.name(),
            createCategoryDTO.description(),
            createCategoryDTO.icon(),
            createCategoryDTO.color(),
            createCategoryDTO.sortOrder()
        ).map(HttpHandlerResult::okIfTruthy);
    }
}
```

**ç”¨æˆ·æ ‡ç­¾æ§åˆ¶å™¨**
```java
@RestController("users/{userId}/tags")
public class UserTagController extends BaseController {
    
    private final UserTagService userTagService;
    private final TagRecommendationService tagRecommendationService;
    
    public UserTagController(UserTagService userTagService,
                           TagRecommendationService tagRecommendationService) {
        this.userTagService = userTagService;
        this.tagRecommendationService = tagRecommendationService;
    }
    
    @PostMapping
    public Mono<HttpHandlerResult<ResponseDTO<Void>>> addUserTag(
            @PathVariable Long userId,
            @RequestBody AddUserTagDTO addUserTagDTO) {
        
        // æƒé™æ£€æŸ¥ï¼šåªèƒ½ç®¡ç†è‡ªå·±çš„æ ‡ç­¾
        return checkUserPermission(userId)
            .then(userTagService.addUserTag(
                userId,
                addUserTagDTO.tagId(),
                addUserTagDTO.isVisible(),
                addUserTagDTO.priority(),
                "USER_ADDED"
            ))
            .then(Mono.fromCallable(() -> HttpHandlerResult.ok()));
    }
    
    @GetMapping
    public Mono<HttpHandlerResult<ResponseDTO<List<Tag>>>> getUserTags(
            @PathVariable Long userId,
            @QueryParam("visibleOnly") Boolean visibleOnly,
            @QueryParam("categoryId") Long categoryId) {
        
        // éæœ¬äººåªèƒ½æŸ¥çœ‹å…¬å¼€æ ‡ç­¾
        if (!isCurrentUser(userId)) {
            visibleOnly = true;
        }
        
        return userTagService.getUserTags(userId, visibleOnly, categoryId)
            .collectList()
            .map(HttpHandlerResult::okIfTruthy);
    }
    
    @DeleteMapping("{tagId}")
    public Mono<HttpHandlerResult<ResponseDTO<Boolean>>> removeUserTag(
            @PathVariable Long userId,
            @PathVariable Long tagId) {
        
        return checkUserPermission(userId)
            .then(userTagService.removeUserTag(userId, tagId))
            .map(HttpHandlerResult::okIfTruthy);
    }
    
    @PutMapping("{tagId}/visibility")
    public Mono<HttpHandlerResult<ResponseDTO<Boolean>>> updateTagVisibility(
            @PathVariable Long userId,
            @PathVariable Long tagId,
            @RequestBody UpdateTagVisibilityDTO updateDTO) {
        
        return checkUserPermission(userId)
            .then(userTagService.updateUserTagVisibility(userId, tagId, updateDTO.isVisible()))
            .map(HttpHandlerResult::okIfTruthy);
    }
    
    @GetMapping("recommendations")
    public Mono<HttpHandlerResult<ResponseDTO<List<Tag>>>> getTagRecommendations(
            @PathVariable Long userId,
            @QueryParam("categoryId") Long categoryId,
            @QueryParam("limit") Integer limit,
            @QueryParam("type") RecommendationType type) {
        
        limit = limit != null ? limit : 20;
        type = type != null ? type : RecommendationType.MIXED_STRATEGY;
        
        return tagRecommendationService.recommendTagsForUser(userId, categoryId, limit, type)
            .collectList()
            .map(HttpHandlerResult::okIfTruthy);
    }
    
    @GetMapping("count")
    public Mono<HttpHandlerResult<ResponseDTO<Integer>>> getUserTagCount(
            @PathVariable Long userId,
            @QueryParam("visibleOnly") Boolean visibleOnly) {
        
        if (!isCurrentUser(userId)) {
            visibleOnly = true;
        }
        
        return userTagService.getUserTagCount(userId, visibleOnly)
            .map(HttpHandlerResult::okIfTruthy);
    }
    
    private Mono<Void> checkUserPermission(Long userId) {
        if (!isCurrentUser(userId)) {
            return Mono.error(ResponseException.get(
                ResponseStatusCode.INSUFFICIENT_PERMISSION,
                "åªèƒ½ç®¡ç†è‡ªå·±çš„æ ‡ç­¾"
            ));
        }
        return Mono.empty();
    }
    
    private boolean isCurrentUser(Long userId) {
        return userId.equals(getCurrentUserId());
    }
}
```

#### 4.2 DTOç±»è®¾è®¡

**è¯·æ±‚DTO**
```java
// åˆ›å»ºæ ‡ç­¾DTO
public record CreateTagDTO(
    @NotBlank String name,
    String description,
    @NotNull Long categoryId,
    Boolean isSystemTag
) {}

// æ·»åŠ ç”¨æˆ·æ ‡ç­¾DTO  
public record AddUserTagDTO(
    @NotNull Long tagId,
    Boolean isVisible,
    Integer priority
) {}

// æ›´æ–°æ ‡ç­¾å¯è§æ€§DTO
public record UpdateTagVisibilityDTO(
    @NotNull Boolean isVisible
) {}

// åˆ›å»ºæ ‡ç­¾åˆ†ç±»DTO
public record CreateTagCategoryDTO(
    @NotBlank String name,
    String description,
    String icon,
    String color,
    Integer sortOrder
) {}
```

#### 4.3 å“åº”çŠ¶æ€ç æ‰©å±•

```java
// ResponseStatusCode.java æ‰©å±•
public enum ResponseStatusCode {
    // ç°æœ‰çŠ¶æ€ç ...
    
    // æ ‡ç­¾ç›¸å…³çŠ¶æ€ç  (2800-2899)
    TAG_ALREADY_EXISTS(2800, "The tag already exists", 409),
    TAG_NOT_FOUND(2801, "The tag was not found", 404),
    TAG_IN_USE(2802, "The tag is in use and cannot be deleted", 409),
    INVALID_TAG_NAME(2803, "Invalid tag name", 400),
    TAG_CATEGORY_ALREADY_EXISTS(2804, "The tag category already exists", 409),
    TAG_CATEGORY_NOT_FOUND(2805, "The tag category was not found", 404),
    USER_TAG_ALREADY_EXISTS(2806, "The user already has this tag", 409),
    USER_TAG_NOT_FOUND(2807, "The user tag was not found", 404),
    TOO_MANY_USER_TAGS(2808, "User has too many tags", 409),
    TAG_RECOMMENDATION_FAILED(2809, "Failed to generate tag recommendations", 500);
}
```

### ç¬¬äº”é˜¶æ®µï¼šç¼“å­˜å’Œæ€§èƒ½ä¼˜åŒ–

#### 5.1 ç¼“å­˜ç­–ç•¥

**Redisç¼“å­˜è®¾è®¡**
```java
@Component
public class TagCacheManager {
    
    private final TurmsRedisClient redisClient;
    private static final String TAG_CACHE_PREFIX = "tag:";
    private static final String TAG_CLOUD_CACHE_PREFIX = "tag:cloud:";
    private static final String USER_TAG_CACHE_PREFIX = "user:tag:";
    private static final int CACHE_TTL = 3600; // 1å°æ—¶
    
    public TagCacheManager(TurmsRedisClient redisClient) {
        this.redisClient = redisClient;
    }
    
    /**
     * ç¼“å­˜çƒ­é—¨æ ‡ç­¾
     */
    public Mono<Void> cacheHotTags(Long categoryId, List<Tag> tags) {
        String key = TAG_CACHE_PREFIX + "hot:" + (categoryId != null ? categoryId : "all");
        return redisClient.setex(key, CACHE_TTL, tags);
    }
    
    public Mono<List<Tag>> getHotTagsFromCache(Long categoryId) {
        String key = TAG_CACHE_PREFIX + "hot:" + (categoryId != null ? categoryId : "all");
        return redisClient.get(key, List.class);
    }
    
    /**
     * ç¼“å­˜æ ‡ç­¾äº‘æ•°æ®
     */
    public Mono<Void> cacheTagCloud(Long categoryId, TagCloudType cloudType, 
                                   List<TagHeatService.TagCloud> tagCloud) {
        String key = TAG_CLOUD_CACHE_PREFIX + cloudType.name().toLowerCase() + ":" + 
                    (categoryId != null ? categoryId : "all");
        return redisClient.setex(key, CACHE_TTL, tagCloud);
    }
    
    public Mono<List<TagHeatService.TagCloud>> getTagCloudFromCache(Long categoryId, TagCloudType cloudType) {
        String key = TAG_CLOUD_CACHE_PREFIX + cloudType.name().toLowerCase() + ":" + 
                    (categoryId != null ? categoryId : "all");
        return redisClient.get(key, List.class);
    }
    
    /**
     * ç¼“å­˜ç”¨æˆ·æ ‡ç­¾
     */
    public Mono<Void> cacheUserTags(Long userId, List<Tag> tags) {
        String key = USER_TAG_CACHE_PREFIX + userId;
        return redisClient.setex(key, CACHE_TTL, tags);
    }
    
    public Mono<List<Tag>> getUserTagsFromCache(Long userId) {
        String key = USER_TAG_CACHE_PREFIX + userId;
        return redisClient.get(key, List.class);
    }
    
    /**
     * æ¸…é™¤ç”¨æˆ·æ ‡ç­¾ç¼“å­˜
     */
    public Mono<Void> evictUserTagCache(Long userId) {
        String key = USER_TAG_CACHE_PREFIX + userId;
        return redisClient.del(key).then();
    }
    
    /**
     * æ¸…é™¤æ ‡ç­¾ç›¸å…³ç¼“å­˜
     */
    public Mono<Void> evictTagCaches() {
        return redisClient.deleteByPattern(TAG_CACHE_PREFIX + "*")
            .then(redisClient.deleteByPattern(TAG_CLOUD_CACHE_PREFIX + "*"));
    }
}
```

#### 5.2 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

**å¼‚æ­¥å¤„ç†å’Œæ‰¹é‡æ“ä½œ**
```java
@Component
public class TagPerformanceOptimizer {
    
    private final TagCacheManager cacheManager;
    private final TagHeatService tagHeatService;
    
    public TagPerformanceOptimizer(TagCacheManager cacheManager,
                                  TagHeatService tagHeatService) {
        this.cacheManager = cacheManager;
        this.tagHeatService = tagHeatService;
    }
    
    /**
     * å¼‚æ­¥æ›´æ–°æ ‡ç­¾çƒ­åº¦
     */
    @Async("tagExecutor")
    public void updateTagHeatAsync(Long tagId, Integer increment) {
        tagHeatService.incrementTagHeat(tagId, increment)
            .doOnSuccess(success -> {
                if (success) {
                    // å¼‚æ­¥æ¸…é™¤ç›¸å…³ç¼“å­˜
                    cacheManager.evictTagCaches().subscribe();
                }
            })
            .subscribe();
    }
    
    /**
     * æ‰¹é‡é¢„çƒ­ç¼“å­˜
     */
    @Scheduled(fixedRate = 300000) // æ¯5åˆ†é’Ÿæ‰§è¡Œä¸€æ¬¡
    public void warmUpCache() {
        // é¢„çƒ­çƒ­é—¨æ ‡ç­¾ç¼“å­˜
        warmUpHotTagsCache();
        
        // é¢„çƒ­æ ‡ç­¾äº‘ç¼“å­˜
        warmUpTagCloudCache();
    }
    
    private void warmUpHotTagsCache() {
        tagHeatService.getHotTags(null, 100)
            .collectList()
            .flatMap(tags -> cacheManager.cacheHotTags(null, tags))
            .subscribe();
    }
    
    private void warmUpTagCloudCache() {
        Arrays.stream(TagCloudType.values())
            .forEach(cloudType -> 
                tagHeatService.getTagCloud(null, 50, cloudType)
                    .collectList()
                    .flatMap(tagCloud -> cacheManager.cacheTagCloud(null, cloudType, tagCloud))
                    .subscribe()
            );
    }
}
```

---

## ğŸ“Š å·¥ä½œé‡ä¸æˆæœ¬è¯„ä¼°

### è¯¦ç»†å·¥ä½œé‡åˆ†è§£

| é˜¶æ®µ | æ¨¡å— | å·¥ä½œé‡(äººå¤©) | éš¾åº¦ç­‰çº§ | ä¼˜å…ˆçº§ | å¤‡æ³¨ |
|------|------|-------------|----------|--------|------|
| **åè®®å±‚è®¾è®¡** | Protobufåè®®å®šä¹‰ | 2å¤© | â˜…â˜…â˜…â˜†â˜† | é«˜ | 4ä¸ªprotoæ–‡ä»¶ |
| | æšä¸¾ç±»å‹å®šä¹‰ | 1å¤© | â˜…â˜…â˜†â˜†â˜† | é«˜ | 3ä¸ªæšä¸¾ |
| **æ•°æ®å±‚å®ç°** | å®ä½“ç±»è®¾è®¡ | 2å¤© | â˜…â˜…â˜…â˜†â˜† | é«˜ | 3ä¸ªå®ä½“ç±» |
| | Repositoryå®ç° | 3å¤© | â˜…â˜…â˜…â˜†â˜† | é«˜ | 3ä¸ªRepository |
| | æ•°æ®åº“ç´¢å¼•åˆ›å»º | 1å¤© | â˜…â˜…â˜†â˜†â˜† | é«˜ | ç´¢å¼•è„šæœ¬ |
| **ä¸šåŠ¡é€»è¾‘å®ç°** | æ ‡ç­¾ç®¡ç†æœåŠ¡ | 4å¤© | â˜…â˜…â˜…â˜†â˜† | é«˜ | CRUD + éªŒè¯ |
| | ç”¨æˆ·æ ‡ç­¾å…³ç³»æœåŠ¡ | 3å¤© | â˜…â˜…â˜…â˜†â˜† | é«˜ | å…³ç³»ç®¡ç† |
| | æ¨èç®—æ³•å¼•æ“ | 8å¤© | â˜…â˜…â˜…â˜…â˜† | ä¸­ | 4ç§æ¨èç®—æ³• |
| | çƒ­åº¦ç»Ÿè®¡æœåŠ¡ | 4å¤© | â˜…â˜…â˜…â˜†â˜† | ä¸­ | ç»Ÿè®¡ + æ ‡ç­¾äº‘ |
| **æ¥å£å±‚å¼€å‘** | REST APIå®ç° | 4å¤© | â˜…â˜…â˜…â˜†â˜† | é«˜ | 2ä¸ªController |
| | DTOç±»è®¾è®¡ | 1å¤© | â˜…â˜…â˜†â˜†â˜† | é«˜ | è¯·æ±‚å“åº”å¯¹è±¡ |
| | çŠ¶æ€ç æ‰©å±• | 1å¤© | â˜…â˜…â˜†â˜†â˜† | é«˜ | 10ä¸ªæ–°çŠ¶æ€ç  |
| **æ€§èƒ½ä¼˜åŒ–** | ç¼“å­˜å±‚å®ç° | 3å¤© | â˜…â˜…â˜…â˜†â˜† | ä¸­ | Redisç¼“å­˜ç­–ç•¥ |
| | å¼‚æ­¥å¤„ç†ä¼˜åŒ– | 2å¤© | â˜…â˜…â˜…â˜†â˜† | ä¸­ | æ‰¹é‡æ“ä½œ |
| **å‰ç«¯é›†æˆ** | æ ‡ç­¾ç®¡ç†ç•Œé¢ | 4å¤© | â˜…â˜…â˜…â˜†â˜† | é«˜ | ç®¡ç†åå° |
| | ç”¨æˆ·æ ‡ç­¾ç•Œé¢ | 4å¤© | â˜…â˜…â˜…â˜†â˜† | é«˜ | ç”¨æˆ·å‰ç«¯ |
| **æµ‹è¯•ä¸æ–‡æ¡£** | å•å…ƒæµ‹è¯• | 3å¤© | â˜…â˜…â˜…â˜†â˜† | é«˜ | æµ‹è¯•è¦†ç›– |
| | é›†æˆæµ‹è¯• | 2å¤© | â˜…â˜…â˜…â˜†â˜† | é«˜ | APIæµ‹è¯• |
| | æ–‡æ¡£ç¼–å†™ | 2å¤© | â˜…â˜…â˜†â˜†â˜† | ä¸­ | APIæ–‡æ¡£ |
| **æ€»è®¡** | - | **54å¤©** | **â˜…â˜…â˜…â˜†â˜†** | - | çº¦8å‘¨ |

### å›¢é˜Ÿé…ç½®å»ºè®®

**æ ‡å‡†å›¢é˜Ÿé…ç½®**ï¼š5äººå›¢é˜Ÿ
- **åç«¯å¼€å‘å·¥ç¨‹å¸ˆ**ï¼š2äºº (è´Ÿè´£æœåŠ¡å±‚å’Œæ•°æ®å±‚)
- **å‰ç«¯å¼€å‘å·¥ç¨‹å¸ˆ**ï¼š1äºº (è´Ÿè´£ç•Œé¢å¼€å‘)
- **ç®—æ³•å·¥ç¨‹å¸ˆ**ï¼š1äºº (è´Ÿè´£æ¨èç®—æ³•)
- **æµ‹è¯•å·¥ç¨‹å¸ˆ**ï¼š1äºº (è´Ÿè´£æµ‹è¯•å’Œè´¨é‡ä¿è¯)

**ç²¾ç®€å›¢é˜Ÿé…ç½®**ï¼š3äººå›¢é˜Ÿ
- **å…¨æ ˆå¼€å‘å·¥ç¨‹å¸ˆ**ï¼š2äºº (è´Ÿè´£åç«¯+å‰ç«¯)
- **æµ‹è¯•å·¥ç¨‹å¸ˆ**ï¼š1äºº (è´Ÿè´£æµ‹è¯•å’Œæ–‡æ¡£)

### æˆæœ¬ä¼°ç®—

**äººåŠ›æˆæœ¬**ï¼š
- æ ‡å‡†å›¢é˜Ÿï¼š54å¤© Ã· 5äºº = 11å¤©/äºº Ã— 5äºº = 55äººå¤©
- ç²¾ç®€å›¢é˜Ÿï¼š54å¤© Ã· 3äºº = 18å¤©/äºº Ã— 3äºº = 54äººå¤©

**æŒ‰æœˆè–ª25Kè®¡ç®—**ï¼š
- æ ‡å‡†å›¢é˜Ÿæˆæœ¬ï¼š55å¤© Ã— 25K Ã· 22å¤© â‰ˆ 62.5ä¸‡
- ç²¾ç®€å›¢é˜Ÿæˆæœ¬ï¼š54å¤© Ã— 25K Ã· 22å¤© â‰ˆ 61.4ä¸‡

**åŸºç¡€è®¾æ–½æˆæœ¬**ï¼š
- Redisç¼“å­˜æœåŠ¡ï¼š500å…ƒ/æœˆ
- ç›‘æ§å·¥å…·ï¼š1000å…ƒ/æœˆ
- æ€»è®¡ï¼šçº¦1500å…ƒ/æœˆ

---

## ğŸ¯ åˆ†é˜¶æ®µå®æ–½è®¡åˆ’

### Phase 1: åŸºç¡€åŠŸèƒ½ (3å‘¨) - MVPç‰ˆæœ¬

**ç›®æ ‡**ï¼šå®ç°æ ¸å¿ƒæ ‡ç­¾ç®¡ç†åŠŸèƒ½

**åŠŸèƒ½æ¸…å•**ï¼š
- âœ… æ ‡ç­¾åˆ†ç±»ç®¡ç†
- âœ… æ ‡ç­¾CRUDæ“ä½œ
- âœ… ç”¨æˆ·æ ‡ç­¾å…³è”
- âœ… åŸºç¡€æŸ¥è¯¢API
- âœ… ç®€å•çš„æ ‡ç­¾äº‘å±•ç¤º

**äº¤ä»˜ç‰©**ï¼š
- æ•°æ®æ¨¡å‹è®¾è®¡å®Œæˆ
- åŸºç¡€APIæ¥å£å¯ç”¨
- ç®¡ç†åå°åŸºç¡€åŠŸèƒ½
- ç”¨æˆ·å¯ä»¥æ·»åŠ /åˆ é™¤æ ‡ç­¾

### Phase 2: é«˜çº§åŠŸèƒ½ (2å‘¨) - å¢å¼ºç‰ˆæœ¬

**ç›®æ ‡**ï¼šå¢åŠ æ™ºèƒ½åŒ–åŠŸèƒ½

**åŠŸèƒ½æ¸…å•**ï¼š
- âœ… æ ‡ç­¾çƒ­åº¦ç»Ÿè®¡
- âœ… åŠ¨æ€æ ‡ç­¾äº‘
- âœ… åŸºç¡€æ¨èç®—æ³•
- âœ… ç¼“å­˜ä¼˜åŒ–
- âœ… æ€§èƒ½ç›‘æ§

**äº¤ä»˜ç‰©**ï¼š
- æ¨èç³»ç»Ÿä¸Šçº¿
- ç¼“å­˜ç­–ç•¥å®æ–½
- æ€§èƒ½æŒ‡æ ‡è¾¾æ ‡

### Phase 3: æ™ºèƒ½åŠŸèƒ½ (3å‘¨) - å®Œæ•´ç‰ˆæœ¬

**ç›®æ ‡**ï¼šå®ç°ä¸ªæ€§åŒ–å’Œå†…å®¹å‘ç°

**åŠŸèƒ½æ¸…å•**ï¼š
- âœ… ä¸ªæ€§åŒ–æ¨èä¼˜åŒ–
- âœ… æ ‡ç­¾ç›¸å…³å†…å®¹å‘ç°
- âœ… é«˜çº§ç®—æ³•è°ƒä¼˜
- âœ… å®Œæ•´çš„ç›‘æ§ä½“ç³»
- âœ… ç”¨æˆ·è¡Œä¸ºåˆ†æ

**äº¤ä»˜ç‰©**ï¼š
- å®Œæ•´åŠŸèƒ½ä¸Šçº¿
- ç®—æ³•æ•ˆæœéªŒè¯
- ç”¨æˆ·ä½“éªŒä¼˜åŒ–

---

## ğŸš¨ é£é™©è¯„ä¼°ä¸åº”å¯¹ç­–ç•¥

### æŠ€æœ¯é£é™©

#### 1. æ¨èç®—æ³•æ•ˆæœä¸ä½³ â˜…â˜…â˜…â˜†â˜†

**é£é™©æè¿°**ï¼šæ¨èå‡†ç¡®ç‡ä½ï¼Œç”¨æˆ·å‚ä¸åº¦ä¸é«˜

**åº”å¯¹ç­–ç•¥**ï¼š
- å®æ–½A/Bæµ‹è¯•éªŒè¯ç®—æ³•æ•ˆæœ
- æä¾›å¤šç§æ¨èç­–ç•¥ä¾›ç”¨æˆ·é€‰æ‹©
- æ”¶é›†ç”¨æˆ·åé¦ˆæŒç»­ä¼˜åŒ–ç®—æ³•
- å‡†å¤‡å¤‡ç”¨çš„ç®€å•è§„åˆ™æ¨è

#### 2. æ€§èƒ½ç“¶é¢ˆ â˜…â˜…â˜…â˜†â˜†

**é£é™©æè¿°**ï¼šæ ‡ç­¾æŸ¥è¯¢å“åº”æ…¢ï¼Œå½±å“ç”¨æˆ·ä½“éªŒ

**åº”å¯¹ç­–ç•¥**ï¼š
- å®æ–½å¤šå±‚ç¼“å­˜ç­–ç•¥
- ä¼˜åŒ–æ•°æ®åº“ç´¢å¼•
- ä½¿ç”¨å¼‚æ­¥å¤„ç†å‡å°‘å“åº”æ—¶é—´
- å‡†å¤‡é™çº§æ–¹æ¡ˆ

#### 3. æ•°æ®ä¸€è‡´æ€§é—®é¢˜ â˜…â˜…â˜†â˜†â˜†

**é£é™©æè¿°**ï¼šç¼“å­˜ä¸æ•°æ®åº“æ•°æ®ä¸ä¸€è‡´

**åº”å¯¹ç­–ç•¥**ï¼š
- å®æ–½ç¼“å­˜å¤±æ•ˆç­–ç•¥
- å®šæœŸæ•°æ®ä¸€è‡´æ€§æ£€æŸ¥
- æä¾›æ‰‹åŠ¨æ¸…ç¼“å­˜å·¥å…·
- ç›‘æ§æ•°æ®ä¸€è‡´æ€§æŒ‡æ ‡

### ä¸šåŠ¡é£é™©

#### 1. ç”¨æˆ·æ¥å—åº¦ä½ â˜…â˜…â˜†â˜†â˜†

**é£é™©æè¿°**ï¼šç”¨æˆ·ä¸æ„¿æ„ä½¿ç”¨æ ‡ç­¾åŠŸèƒ½

**åº”å¯¹ç­–ç•¥**ï¼š
- æä¾›æ ‡ç­¾ä½¿ç”¨å¼•å¯¼
- è®¾è®¡æ¿€åŠ±æœºåˆ¶é¼“åŠ±ä½¿ç”¨
- ç®€åŒ–æ ‡ç­¾æ“ä½œæµç¨‹
- å±•ç¤ºæ ‡ç­¾å¸¦æ¥çš„ä»·å€¼

#### 2. å†…å®¹è´¨é‡é—®é¢˜ â˜…â˜…â˜…â˜†â˜†

**é£é™©æè¿°**ï¼šç”¨æˆ·åˆ›å»ºä½è´¨é‡æˆ–ä¸å½“æ ‡ç­¾

**åº”å¯¹ç­–ç•¥**ï¼š
- å®æ–½æ ‡ç­¾å®¡æ ¸æœºåˆ¶
- æä¾›ä¸¾æŠ¥åŠŸèƒ½
- è®¾ç½®æ ‡ç­¾åˆ›å»ºé™åˆ¶
- å»ºç«‹æ ‡ç­¾ç®¡ç†å‘˜åˆ¶åº¦

---

## ğŸ“ˆ æˆåŠŸæŒ‡æ ‡ä¸ç›‘æ§

### æ ¸å¿ƒKPIæŒ‡æ ‡

#### 1. ç”¨æˆ·å‚ä¸åº¦æŒ‡æ ‡
- **æ ‡ç­¾æ·»åŠ ç‡**ï¼šæ–°ç”¨æˆ·7å¤©å†…æ·»åŠ æ ‡ç­¾çš„æ¯”ä¾‹ (ç›®æ ‡: >60%)
- **å¹³å‡ç”¨æˆ·æ ‡ç­¾æ•°**ï¼šæ¯ä¸ªç”¨æˆ·å¹³å‡æ‹¥æœ‰çš„æ ‡ç­¾æ•°é‡ (ç›®æ ‡: 5-10ä¸ª)
- **æ ‡ç­¾ä½¿ç”¨æ´»è·ƒåº¦**ï¼šæ¯æ—¥æœ‰æ ‡ç­¾æ“ä½œçš„ç”¨æˆ·æ¯”ä¾‹ (ç›®æ ‡: >20%)

#### 2. ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡
- **æ ‡ç­¾æŸ¥è¯¢å“åº”æ—¶é—´**ï¼šP95å“åº”æ—¶é—´ (ç›®æ ‡: <100ms)
- **æ¨èæ¥å£å“åº”æ—¶é—´**ï¼šP95å“åº”æ—¶é—´ (ç›®æ ‡: <200ms)
- **æ ‡ç­¾äº‘åŠ è½½æ—¶é—´**ï¼šé¦–å±åŠ è½½æ—¶é—´ (ç›®æ ‡: <150ms)

#### 3. æ¨èæ•ˆæœæŒ‡æ ‡
- **æ¨èç‚¹å‡»ç‡**ï¼šç”¨æˆ·ç‚¹å‡»æ¨èæ ‡ç­¾çš„æ¯”ä¾‹ (ç›®æ ‡: >15%)
- **æ¨èè½¬åŒ–ç‡**ï¼šç”¨æˆ·æ·»åŠ æ¨èæ ‡ç­¾çš„æ¯”ä¾‹ (ç›®æ ‡: >8%)
- **æ¨èè¦†ç›–ç‡**ï¼šèƒ½å¤Ÿè·å¾—æ¨èçš„ç”¨æˆ·æ¯”ä¾‹ (ç›®æ ‡: >90%)

### ç›‘æ§æ–¹æ¡ˆ

#### 1. å®æ—¶ç›‘æ§
```java
@Component
public class TagMetricsCollector {
    
    private final MeterRegistry meterRegistry;
    
    // æ ‡ç­¾æ“ä½œè®¡æ•°å™¨
    private final Counter tagCreateCounter;
    private final Counter tagDeleteCounter;
    private final Counter userTagAddCounter;
    
    // å“åº”æ—¶é—´è®¡æ—¶å™¨
    private final Timer tagQueryTimer;
    private final Timer recommendationTimer;
    
    public TagMetricsCollector(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.tagCreateCounter = Counter.builder("tag.create.count").register(meterRegistry);
        this.tagDeleteCounter = Counter.builder("tag.delete.count").register(meterRegistry);
        this.userTagAddCounter = Counter.builder("user.tag.add.count").register(meterRegistry);
        this.tagQueryTimer = Timer.builder("tag.query.duration").register(meterRegistry);
        this.recommendationTimer = Timer.builder("tag.recommendation.duration").register(meterRegistry);
    }
    
    public void recordTagCreate() {
        tagCreateCounter.increment();
    }
    
    public void recordTagQuery(Duration duration) {
        tagQueryTimer.record(duration);
    }
    
    // å…¶ä»–æŒ‡æ ‡è®°å½•æ–¹æ³•...
}
```

#### 2. ä¸šåŠ¡ç›‘æ§Dashboard

**Grafanaç›‘æ§é¢æ¿**ï¼š
- æ ‡ç­¾ç³»ç»Ÿæ•´ä½“æŒ‡æ ‡
- ç”¨æˆ·æ ‡ç­¾ä½¿ç”¨è¶‹åŠ¿
- æ¨èç®—æ³•æ•ˆæœåˆ†æ
- ç³»ç»Ÿæ€§èƒ½ç›‘æ§
- é”™è¯¯ç‡å’Œå¼‚å¸¸ç›‘æ§

---

## ğŸ’¡ æœ€ç»ˆå»ºè®®æ€»ç»“

### âœ… æ¨èå®æ–½æ–¹æ¡ˆ

**æ ¸å¿ƒç»“è®º**ï¼šé‡‡ç”¨ç‹¬ç«‹æ ‡ç­¾å­ç³»ç»Ÿæ¶æ„

### ğŸ¯ å…³é”®ä¼˜åŠ¿

1. **æ¶æ„åˆç†**ï¼šèŒè´£æ¸…æ™°ï¼Œä¾¿äºç»´æŠ¤å’Œæ‰©å±•
2. **æ€§èƒ½ä¼˜ç§€**ï¼šä¸“é—¨çš„ç¼“å­˜å’Œä¼˜åŒ–ç­–ç•¥
3. **åŠŸèƒ½å®Œæ•´**ï¼šè¦†ç›–æ‰€æœ‰ä¸šåŠ¡éœ€æ±‚
4. **é£é™©å¯æ§**ï¼šåˆ†é˜¶æ®µå®æ–½ï¼Œé€æ­¥éªŒè¯
5. **æˆæœ¬åˆç†**ï¼š8å‘¨å¼€å‘å‘¨æœŸï¼Œçº¦60ä¸‡æˆæœ¬

### ğŸ“‹ å®æ–½å»ºè®®

1. **ä¼˜å…ˆçº§ç­–ç•¥**ï¼šå…ˆå®ç°MVPç‰ˆæœ¬ï¼Œå¿«é€ŸéªŒè¯ç”¨æˆ·éœ€æ±‚
2. **æŠ€æœ¯é€‰å‹**ï¼šåŸºäºç°æœ‰Turmsæ¶æ„ï¼Œæœ€å°åŒ–æŠ€æœ¯é£é™©
3. **å›¢é˜Ÿé…ç½®**ï¼š3-5äººå›¢é˜Ÿï¼Œ8å‘¨å®Œæˆå…¨éƒ¨åŠŸèƒ½
4. **ç›‘æ§ä½“ç³»**ï¼šä»ç¬¬ä¸€é˜¶æ®µå°±å»ºç«‹å®Œæ•´çš„ç›‘æ§æŒ‡æ ‡

### ğŸš€ æœªæ¥æ‰©å±•æ–¹å‘

1. **AIé©±åŠ¨**ï¼šé›†æˆæœºå™¨å­¦ä¹ æå‡æ¨èæ•ˆæœ
2. **ç¤¾äº¤åŒ–**ï¼šåŸºäºæ ‡ç­¾çš„ç¤¾äº¤åŒ¹é…å’Œç¾¤ç»„æ¨è
3. **å†…å®¹ç”Ÿæ€**ï¼šæ ‡ç­¾é©±åŠ¨çš„å†…å®¹åˆ†å‘å’Œå‘ç°
4. **å•†ä¸šåŒ–**ï¼šåŸºäºæ ‡ç­¾çš„ç²¾å‡†è¥é”€å’Œå¹¿å‘Šç³»ç»Ÿ

è¿™ä¸ªæ–¹æ¡ˆæ—¢æ»¡è¶³äº†å½“å‰çš„ä¸šåŠ¡éœ€æ±‚ï¼Œåˆä¸ºæœªæ¥çš„æ‰©å±•ç•™ä¸‹äº†å……è¶³çš„ç©ºé—´ï¼Œæ˜¯åœ¨ç°æœ‰æ¶æ„ä¸‹çš„æœ€ä¼˜é€‰æ‹©ã€‚

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
**åˆ›å»ºæ—¥æœŸ**ï¼š2025-06-18  
**é€‚ç”¨é¡¹ç›®**ï¼šTurmså³æ—¶é€šè®¯ç³»ç»Ÿ  
**è®¾è®¡å›¢é˜Ÿ**ï¼šæ¶æ„è®¾è®¡ç»„