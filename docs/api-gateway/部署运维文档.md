# Turms API网关部署运维文档

## 文档信息

| 项目 | 值 |
|------|-----|
| 文档名称 | Turms API网关部署运维文档 |
| 版本 | v1.0.0 |
| 创建日期 | 2025-01-19 |
| 最后更新 | 2025-01-19 |
| 目标读者 | 运维工程师、DevOps工程师 |

## 1. 环境准备

### 1.1 硬件要求

#### 1.1.1 最小配置

| 组件 | 配置 | 说明 |
|------|------|------|
| CPU | 2核 | 支持基本运行 |
| 内存 | 4GB | 包含JVM堆内存 |
| 存储 | 20GB | 系统和日志存储 |
| 网络 | 1Gbps | 内网带宽 |

#### 1.1.2 推荐配置

| 组件 | 配置 | 说明 |
|------|------|------|
| CPU | 4核+ | 支持高并发 |
| 内存 | 8GB+ | 充足的JVM内存 |
| 存储 | 100GB SSD | 高速存储和日志 |
| 网络 | 10Gbps | 高速网络 |

#### 1.1.3 生产环境配置

| 组件 | 配置 | 说明 |
|------|------|------|
| CPU | 8核+ | 支持大规模部署 |
| 内存 | 16GB+ | 大内存支持 |
| 存储 | 500GB NVMe SSD | 高性能存储 |
| 网络 | 25Gbps+ | 企业级网络 |

### 1.2 软件要求

#### 1.2.1 操作系统

| 系统 | 版本 | 状态 |
|------|------|------|
| Ubuntu | 20.04+ | 推荐 |
| CentOS | 8+ | 支持 |
| RHEL | 8+ | 支持 |
| Amazon Linux | 2 | 支持 |

#### 1.2.2 Java环境

```bash
# 安装OpenJDK 21
# Ubuntu/Debian
sudo apt update
sudo apt install openjdk-21-jdk

# CentOS/RHEL
sudo yum install java-21-openjdk-devel

# 验证安装
java -version
javac -version
```

#### 1.2.3 Docker环境

```bash
# 安装Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh

# 安装Docker Compose
sudo curl -L "https://github.com/docker/compose/releases/download/v2.21.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose

# 验证安装
docker --version
docker-compose --version
```

### 1.3 依赖服务

#### 1.3.1 Redis部署

```bash
# 使用Docker部署Redis
docker run -d \
  --name turms-redis \
  -p 6379:6379 \
  -v redis_data:/data \
  redis:7.4.1-alpine \
  redis-server --appendonly yes

# 验证连接
redis-cli ping
```

#### 1.3.2 Consul部署

```bash
# 使用Docker部署Consul
docker run -d \
  --name turms-consul \
  -p 8500:8500 \
  -v consul_data:/consul/data \
  consul:1.17 \
  agent -dev -client=0.0.0.0 -ui

# 验证服务
curl http://localhost:8500/v1/status/leader
```

## 2. 应用部署

### 2.1 JAR包部署

#### 2.1.1 构建应用

```bash
# 克隆代码
git clone https://github.com/turms-im/turms.git
cd turms

# 构建网关服务
mvn clean package -pl turms-api-gateway -DskipTests

# 查看构建结果
ls -la turms-api-gateway/target/turms-api-gateway-*.jar
```

#### 2.1.2 配置文件

```bash
# 创建配置目录
sudo mkdir -p /opt/turms/config
sudo mkdir -p /opt/turms/logs

# 复制配置文件
sudo cp turms-api-gateway/src/main/resources/application.yml /opt/turms/config/

# 创建生产环境配置
sudo tee /opt/turms/config/application-prod.yml > /dev/null <<EOF
spring:
  data:
    redis:
      host: localhost
      port: 6379
  cloud:
    consul:
      host: localhost
      port: 8500

turms:
  gateway:
    jwt:
      secret: \${JWT_SECRET:turms-production-secret-key-must-be-changed}
      expiration: 3600
EOF
```

#### 2.1.3 启动脚本

```bash
# 创建启动脚本
sudo tee /opt/turms/start-gateway.sh > /dev/null <<'EOF'
#!/bin/bash

APP_NAME="turms-api-gateway"
APP_JAR="/opt/turms/turms-api-gateway.jar"
CONFIG_DIR="/opt/turms/config"
LOG_DIR="/opt/turms/logs"
PID_FILE="/opt/turms/gateway.pid"

# JVM参数
JVM_OPTS="-Xms512m -Xmx1g"
JVM_OPTS="$JVM_OPTS -XX:+UseG1GC"
JVM_OPTS="$JVM_OPTS -XX:+UseStringDeduplication" 
JVM_OPTS="$JVM_OPTS -XX:MaxGCPauseMillis=100"
JVM_OPTS="$JVM_OPTS -XX:+HeapDumpOnOutOfMemoryError"
JVM_OPTS="$JVM_OPTS -XX:HeapDumpPath=$LOG_DIR"

# 应用参数
APP_OPTS="--spring.profiles.active=prod"
APP_OPTS="$APP_OPTS --spring.config.location=classpath:/,$CONFIG_DIR/"
APP_OPTS="$APP_OPTS --logging.file.name=$LOG_DIR/gateway.log"

# 启动应用
nohup java $JVM_OPTS -jar $APP_JAR $APP_OPTS > $LOG_DIR/startup.log 2>&1 &
echo $! > $PID_FILE

echo "Turms API Gateway started with PID: $(cat $PID_FILE)"
EOF

# 设置执行权限
sudo chmod +x /opt/turms/start-gateway.sh
```

#### 2.1.4 停止脚本

```bash
# 创建停止脚本
sudo tee /opt/turms/stop-gateway.sh > /dev/null <<'EOF'
#!/bin/bash

PID_FILE="/opt/turms/gateway.pid"

if [ -f $PID_FILE ]; then
    PID=$(cat $PID_FILE)
    echo "Stopping Turms API Gateway (PID: $PID)..."
    kill $PID
    
    # 等待进程结束
    for i in {1..30}; do
        if ! kill -0 $PID 2>/dev/null; then
            echo "Gateway stopped successfully"
            rm -f $PID_FILE
            exit 0
        fi
        sleep 1
    done
    
    # 强制停止
    echo "Force stopping gateway..."
    kill -9 $PID
    rm -f $PID_FILE
else
    echo "PID file not found. Gateway may not be running."
fi
EOF

# 设置执行权限
sudo chmod +x /opt/turms/stop-gateway.sh
```

#### 2.1.5 系统服务

```bash
# 创建systemd服务文件
sudo tee /etc/systemd/system/turms-gateway.service > /dev/null <<EOF
[Unit]
Description=Turms API Gateway
After=network.target

[Service]
Type=forking
User=turms
Group=turms
ExecStart=/opt/turms/start-gateway.sh
ExecStop=/opt/turms/stop-gateway.sh
PIDFile=/opt/turms/gateway.pid
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

# 创建用户
sudo useradd -r -s /bin/false turms
sudo chown -R turms:turms /opt/turms

# 启用服务
sudo systemctl daemon-reload
sudo systemctl enable turms-gateway
sudo systemctl start turms-gateway
sudo systemctl status turms-gateway
```

### 2.2 Docker部署

#### 2.2.1 单容器部署

```bash
# 构建镜像
cd turms-api-gateway
docker build -f docker/Dockerfile -t turms/api-gateway:latest .

# 运行容器
docker run -d \
  --name turms-api-gateway \
  -p 8080:8080 \
  -e SPRING_PROFILES_ACTIVE=prod \
  -e SPRING_DATA_REDIS_HOST=redis \
  -e SPRING_CLOUD_CONSUL_HOST=consul \
  -e TURMS_GATEWAY_JWT_SECRET=your-production-secret-key \
  --link turms-redis:redis \
  --link turms-consul:consul \
  turms/api-gateway:latest
```

#### 2.2.2 Docker Compose部署

```bash
# 使用提供的docker-compose文件
cd turms-api-gateway/docker
docker-compose up -d

# 查看服务状态
docker-compose ps

# 查看日志
docker-compose logs -f turms-api-gateway
```

### 2.3 Kubernetes部署

#### 2.3.1 命名空间

```yaml
# namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: turms
  labels:
    name: turms
```

#### 2.3.2 ConfigMap

```yaml
# configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: turms-gateway-config
  namespace: turms
data:
  application.yml: |
    spring:
      profiles:
        active: prod
      data:
        redis:
          host: turms-redis
          port: 6379
      cloud:
        consul:
          host: turms-consul
          port: 8500
    turms:
      gateway:
        jwt:
          expiration: 3600
```

#### 2.3.3 Secret

```yaml
# secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: turms-gateway-secret
  namespace: turms
type: Opaque
data:
  jwt-secret: <base64-encoded-secret>
```

#### 2.3.4 Deployment

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: turms-api-gateway
  namespace: turms
  labels:
    app: turms-api-gateway
spec:
  replicas: 3
  selector:
    matchLabels:
      app: turms-api-gateway
  template:
    metadata:
      labels:
        app: turms-api-gateway
    spec:
      containers:
      - name: api-gateway
        image: turms/api-gateway:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "prod"
        - name: TURMS_GATEWAY_JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: turms-gateway-secret
              key: jwt-secret
        volumeMounts:
        - name: config-volume
          mountPath: /app/config
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
      volumes:
      - name: config-volume
        configMap:
          name: turms-gateway-config
```

#### 2.3.5 Service

```yaml
# service.yaml
apiVersion: v1
kind: Service
metadata:
  name: turms-api-gateway
  namespace: turms
  labels:
    app: turms-api-gateway
spec:
  type: ClusterIP
  ports:
  - port: 8080
    targetPort: 8080
    protocol: TCP
  selector:
    app: turms-api-gateway
```

#### 2.3.6 Ingress

```yaml
# ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: turms-api-gateway
  namespace: turms
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - api.turms.im
    secretName: turms-api-tls
  rules:
  - host: api.turms.im
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: turms-api-gateway
            port:
              number: 8080
```

## 3. 监控配置

### 3.1 Prometheus配置

#### 3.1.1 Prometheus配置文件

```yaml
# prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'turms-api-gateway'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['turms-api-gateway:8080']
    scrape_interval: 5s
    scrape_timeout: 3s
```

#### 3.1.2 Docker部署Prometheus

```bash
# 创建配置目录
mkdir -p /opt/monitoring/prometheus

# 复制配置文件
cp prometheus.yml /opt/monitoring/prometheus/

# 运行Prometheus
docker run -d \
  --name turms-prometheus \
  -p 9090:9090 \
  -v /opt/monitoring/prometheus:/etc/prometheus \
  -v prometheus_data:/prometheus \
  prom/prometheus:v2.48.1 \
  --config.file=/etc/prometheus/prometheus.yml \
  --storage.tsdb.path=/prometheus \
  --web.console.libraries=/etc/prometheus/console_libraries \
  --web.console.templates=/etc/prometheus/consoles \
  --storage.tsdb.retention.time=200h \
  --web.enable-lifecycle
```

### 3.2 Grafana配置

#### 3.2.1 部署Grafana

```bash
# 运行Grafana
docker run -d \
  --name turms-grafana \
  -p 3000:3000 \
  -e GF_SECURITY_ADMIN_USER=admin \
  -e GF_SECURITY_ADMIN_PASSWORD=admin \
  -v grafana_data:/var/lib/grafana \
  grafana/grafana:10.2.3
```

#### 3.2.2 导入仪表板

```json
{
  "dashboard": {
    "title": "Turms API Gateway",
    "panels": [
      {
        "title": "Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(http_server_requests_seconds_count[1m])",
            "legendFormat": "RPS"
          }
        ]
      },
      {
        "title": "Response Time",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_server_requests_seconds_bucket[1m]))",
            "legendFormat": "P95"
          }
        ]
      }
    ]
  }
}
```

### 3.3 告警配置

#### 3.3.1 AlertManager配置

```yaml
# alertmanager.yml
global:
  smtp_smarthost: 'smtp.gmail.com:587'
  smtp_from: 'alerts@turms.im'
  smtp_auth_username: 'alerts@turms.im'
  smtp_auth_password: 'password'

route:
  group_by: ['alertname']
  group_wait: 10s
  group_interval: 10s
  repeat_interval: 1h
  receiver: 'web.hook'

receivers:
- name: 'web.hook'
  email_configs:
  - to: 'admin@turms.im'
    subject: 'Turms Alert: {{ .GroupLabels.alertname }}'
    body: |
      {{ range .Alerts }}
      Alert: {{ .Annotations.summary }}
      Description: {{ .Annotations.description }}
      {{ end }}
```

#### 3.3.2 告警规则

```yaml
# alerts.yml
groups:
- name: turms-gateway
  rules:
  - alert: HighErrorRate
    expr: rate(http_server_requests_seconds_count{status=~"5.."}[1m]) > 0.1
    for: 1m
    labels:
      severity: critical
    annotations:
      summary: "High error rate detected"
      description: "Error rate is {{ $value }} requests per second"
      
  - alert: HighResponseTime
    expr: histogram_quantile(0.95, rate(http_server_requests_seconds_bucket[1m])) > 1
    for: 2m
    labels:
      severity: warning
    annotations:
      summary: "High response time detected"
      description: "95th percentile response time is {{ $value }} seconds"
      
  - alert: ServiceDown
    expr: up{job="turms-api-gateway"} == 0
    for: 30s
    labels:
      severity: critical
    annotations:
      summary: "Turms API Gateway is down"
      description: "Gateway service has been down for more than 30 seconds"
```

## 4. 日志管理

### 4.1 日志配置

#### 4.1.1 Logback配置

```xml
<!-- logback-spring.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <springProfile name="prod">
        <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
            <file>/opt/turms/logs/gateway.log</file>
            <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                <fileNamePattern>/opt/turms/logs/gateway.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
                <maxFileSize>100MB</maxFileSize>
                <maxHistory>30</maxHistory>
                <totalSizeCap>10GB</totalSizeCap>
            </rollingPolicy>
            <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
                <providers>
                    <timestamp/>
                    <logLevel/>
                    <loggerName/>
                    <message/>
                    <mdc/>
                    <stackTrace/>
                </providers>
            </encoder>
        </appender>
        
        <root level="INFO">
            <appender-ref ref="FILE"/>
        </root>
    </springProfile>
</configuration>
```

### 4.2 ELK Stack部署

#### 4.2.1 Elasticsearch

```bash
# 运行Elasticsearch
docker run -d \
  --name turms-elasticsearch \
  -p 9200:9200 \
  -e "discovery.type=single-node" \
  -e "xpack.security.enabled=false" \
  -v elasticsearch_data:/usr/share/elasticsearch/data \
  elasticsearch:8.17.0
```

#### 4.2.2 Logstash

```yaml
# logstash.conf
input {
  file {
    path => "/opt/turms/logs/*.log"
    start_position => "beginning"
    codec => "json"
  }
}

filter {
  if [logger_name] {
    mutate {
      add_field => { "service" => "turms-api-gateway" }
    }
  }
}

output {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "turms-gateway-%{+YYYY.MM.dd}"
  }
}
```

#### 4.2.3 Kibana

```bash
# 运行Kibana
docker run -d \
  --name turms-kibana \
  -p 5601:5601 \
  -e "ELASTICSEARCH_HOSTS=http://elasticsearch:9200" \
  --link turms-elasticsearch:elasticsearch \
  kibana:8.17.0
```

## 5. 备份与恢复

### 5.1 配置备份

#### 5.1.1 备份脚本

```bash
#!/bin/bash
# backup-config.sh

BACKUP_DIR="/opt/turms/backup"
CONFIG_DIR="/opt/turms/config"
DATE=$(date +%Y%m%d_%H%M%S)

# 创建备份目录
mkdir -p $BACKUP_DIR

# 备份配置文件
tar -czf $BACKUP_DIR/config_$DATE.tar.gz -C $CONFIG_DIR .

# 保留最近30天的备份
find $BACKUP_DIR -name "config_*.tar.gz" -mtime +30 -delete

echo "Configuration backup completed: config_$DATE.tar.gz"
```

#### 5.1.2 定时备份

```bash
# 添加到crontab
crontab -e

# 每天凌晨2点执行备份
0 2 * * * /opt/turms/backup-config.sh
```

### 5.2 数据备份

#### 5.2.1 Redis备份

```bash
#!/bin/bash
# backup-redis.sh

BACKUP_DIR="/opt/turms/backup/redis"
DATE=$(date +%Y%m%d_%H%M%S)

mkdir -p $BACKUP_DIR

# 备份Redis数据
redis-cli BGSAVE
sleep 10
cp /var/lib/redis/dump.rdb $BACKUP_DIR/redis_$DATE.rdb

# 保留最近7天的备份
find $BACKUP_DIR -name "redis_*.rdb" -mtime +7 -delete

echo "Redis backup completed: redis_$DATE.rdb"
```

### 5.3 恢复流程

#### 5.3.1 配置恢复

```bash
#!/bin/bash
# restore-config.sh

BACKUP_FILE=$1
CONFIG_DIR="/opt/turms/config"

if [ -z "$BACKUP_FILE" ]; then
    echo "Usage: $0 <backup_file>"
    exit 1
fi

# 停止服务
sudo systemctl stop turms-gateway

# 备份当前配置
mv $CONFIG_DIR $CONFIG_DIR.old

# 恢复配置
mkdir -p $CONFIG_DIR
tar -xzf $BACKUP_FILE -C $CONFIG_DIR

# 启动服务
sudo systemctl start turms-gateway

echo "Configuration restored from $BACKUP_FILE"
```

## 6. 性能调优

### 6.1 JVM调优

#### 6.1.1 内存配置

```bash
# 生产环境JVM参数
JVM_OPTS="-Xms1g -Xmx2g"
JVM_OPTS="$JVM_OPTS -XX:MetaspaceSize=256m"
JVM_OPTS="$JVM_OPTS -XX:MaxMetaspaceSize=512m"
JVM_OPTS="$JVM_OPTS -XX:NewRatio=2"
JVM_OPTS="$JVM_OPTS -XX:SurvivorRatio=8"
```

#### 6.1.2 GC调优

```bash
# G1GC配置
JVM_OPTS="$JVM_OPTS -XX:+UseG1GC"
JVM_OPTS="$JVM_OPTS -XX:MaxGCPauseMillis=200"
JVM_OPTS="$JVM_OPTS -XX:G1HeapRegionSize=16m"
JVM_OPTS="$JVM_OPTS -XX:G1NewSizePercent=30"
JVM_OPTS="$JVM_OPTS -XX:G1MaxNewSizePercent=40"
JVM_OPTS="$JVM_OPTS -XX:InitiatingHeapOccupancyPercent=45"
```

#### 6.1.3 监控参数

```bash
# GC日志
JVM_OPTS="$JVM_OPTS -Xlog:gc*:logs/gc.log:time,tags"
JVM_OPTS="$JVM_OPTS -XX:+HeapDumpOnOutOfMemoryError"
JVM_OPTS="$JVM_OPTS -XX:HeapDumpPath=logs/"
```

### 6.2 应用调优

#### 6.2.1 连接池配置

```yaml
spring:
  data:
    redis:
      lettuce:
        pool:
          max-active: 16
          max-idle: 8
          min-idle: 4
          max-wait: 3000ms
        shutdown-timeout: 100ms
```

#### 6.2.2 限流配置优化

```yaml
turms:
  gateway:
    rate-limit:
      default:
        replenish-rate: 20
        burst-capacity: 40
      services:
        turms-service:
          replenish-rate: 200
          burst-capacity: 400
```

### 6.3 系统调优

#### 6.3.1 文件描述符

```bash
# 增加文件描述符限制
echo "* soft nofile 65536" >> /etc/security/limits.conf
echo "* hard nofile 65536" >> /etc/security/limits.conf

# 验证设置
ulimit -n
```

#### 6.3.2 网络参数

```bash
# 优化TCP参数
echo 'net.core.somaxconn = 65535' >> /etc/sysctl.conf
echo 'net.ipv4.tcp_max_syn_backlog = 65535' >> /etc/sysctl.conf
echo 'net.core.netdev_max_backlog = 65535' >> /etc/sysctl.conf

# 应用设置
sysctl -p
```

## 7. 故障排查

### 7.1 常见问题

#### 7.1.1 启动失败

**问题描述：** 应用启动失败

**排查步骤：**
1. 检查Java版本：`java -version`
2. 检查端口占用：`netstat -tulpn | grep 8080`
3. 检查日志：`tail -f /opt/turms/logs/startup.log`
4. 检查配置：`cat /opt/turms/config/application.yml`

**常见原因：**
- Java版本不兼容
- 端口被占用
- 配置文件格式错误
- 依赖服务未启动

#### 7.1.2 服务连接失败

**问题描述：** 无法连接到后端服务

**排查步骤：**
1. 检查服务发现：`curl http://localhost:8500/v1/catalog/services`
2. 检查网络连通性：`telnet backend-service 8080`
3. 检查路由配置：`curl http://localhost:8080/actuator/gateway/routes`
4. 检查服务健康状态：`curl http://localhost:8080/actuator/health`

#### 7.1.3 性能问题

**问题描述：** 响应时间过长

**排查步骤：**
1. 检查JVM状态：`jstat -gc <pid>`
2. 检查线程状态：`jstack <pid>`
3. 检查内存使用：`jmap -histo <pid>`
4. 检查监控指标：访问Grafana仪表板

### 7.2 诊断工具

#### 7.2.1 JVM诊断

```bash
# 查看JVM进程
jps -v

# 查看GC情况
jstat -gc <pid> 1s

# 查看内存使用
jmap -heap <pid>

# 生成线程转储
jstack <pid> > thread_dump.txt

# 生成内存转储
jmap -dump:live,format=b,file=heap_dump.hprof <pid>
```

#### 7.2.2 网络诊断

```bash
# 检查端口监听
netstat -tulpn | grep :8080

# 检查连接状态
ss -tulpn | grep :8080

# 网络连通性测试
curl -I http://localhost:8080/actuator/health

# DNS解析测试
nslookup turms-service
```

#### 7.2.3 应用诊断

```bash
# 检查应用状态
curl http://localhost:8080/actuator/health

# 查看配置信息
curl http://localhost:8080/actuator/configprops

# 查看环境变量
curl http://localhost:8080/actuator/env

# 查看指标数据
curl http://localhost:8080/actuator/metrics
```

## 8. 安全加固

### 8.1 网络安全

#### 8.1.1 防火墙配置

```bash
# UFW配置（Ubuntu）
sudo ufw enable
sudo ufw allow 22/tcp    # SSH
sudo ufw allow 8080/tcp  # API Gateway
sudo ufw deny 9090/tcp   # Prometheus (internal only)
sudo ufw deny 3000/tcp   # Grafana (internal only)

# iptables配置
iptables -A INPUT -p tcp --dport 8080 -j ACCEPT
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
iptables -P INPUT DROP
```

#### 8.1.2 SSL/TLS配置

```yaml
# 启用HTTPS
server:
  port: 8443
  ssl:
    enabled: true
    key-store: classpath:keystore.p12
    key-store-password: password
    key-store-type: PKCS12
    key-alias: turms-gateway
```

### 8.2 应用安全

#### 8.2.1 JWT密钥管理

```bash
# 生成强密钥
openssl rand -base64 32

# 环境变量设置
export TURMS_GATEWAY_JWT_SECRET="$(openssl rand -base64 32)"

# Kubernetes Secret
kubectl create secret generic turms-jwt-secret \
  --from-literal=jwt-secret="$(openssl rand -base64 32)"
```

#### 8.2.2 访问控制

```yaml
# 限制管理端点访问
management:
  endpoints:
    web:
      base-path: /actuator
      exposure:
        include: health,info,prometheus
  endpoint:
    health:
      show-details: when-authorized
```

### 8.3 审计日志

#### 8.3.1 访问日志

```yaml
# 启用访问日志
logging:
  level:
    org.springframework.web.filter.CommonsRequestLoggingFilter: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
```

#### 8.3.2 安全事件日志

```java
// 记录安全事件
@EventListener
public void handleAuthenticationFailure(AuthenticationFailureEvent event) {
    log.warn("Authentication failed for user: {}, IP: {}", 
            event.getAuthentication().getName(),
            getClientIP(event.getRequest()));
}
```

---

**维护计划**

| 任务 | 频率 | 负责人 |
|------|------|--------|
| 日志清理 | 每周 | 运维团队 |
| 配置备份 | 每天 | 自动化 |
| 安全扫描 | 每月 | 安全团队 |
| 性能评估 | 每季度 | 开发团队 |

**联系支持**

如需技术支持，请联系运维团队或查阅相关文档。