# Turms API网关开发者指南

## 文档信息

| 项目 | 值 |
|------|-----|
| 文档名称 | Turms API网关开发者指南 |
| 版本 | v1.0.0 |
| 创建日期 | 2025-01-19 |
| 最后更新 | 2025-01-19 |
| 目标读者 | 后端开发工程师、架构师 |

## 1. 开发环境搭建

### 1.1 前置要求

#### 1.1.1 开发工具

| 工具 | 版本 | 说明 |
|------|------|------|
| JDK | 21+ | OpenJDK或Oracle JDK |
| Maven | 3.8+ | 构建工具 |
| IDE | - | IntelliJ IDEA或Eclipse |
| Git | 2.0+ | 版本控制 |
| Docker | 20+ | 容器化运行 |

#### 1.1.2 环境准备

```bash
# 检查Java版本
java -version

# 检查Maven版本
mvn -version

# 克隆项目
git clone https://github.com/turms-im/turms.git
cd turms

# 构建项目
mvn clean compile -pl turms-api-gateway
```

### 1.2 IDE配置

#### 1.2.1 IntelliJ IDEA配置

```xml
<!-- .idea/codeStyles/Project.xml -->
<component name="ProjectCodeStyleConfiguration">
  <code_scheme name="Project" version="173">
    <JavaCodeStyleSettings>
      <option name="IMPORT_LAYOUT_TABLE">
        <value>
          <package name="" withSubpackages="true" static="false" />
          <emptyLine />
          <package name="im.turms" withSubpackages="true" static="false" />
          <emptyLine />
          <package name="" withSubpackages="true" static="true" />
        </value>
      </option>
    </JavaCodeStyleSettings>
  </code_scheme>
</component>
```

#### 1.2.2 代码格式化

```xml
<!-- spotless配置已在pom.xml中定义 -->
<!-- 执行格式化 -->
mvn spotless:apply
```

### 1.3 本地开发环境

#### 1.3.1 依赖服务启动

```bash
# 启动Redis
docker run -d --name dev-redis -p 6379:6379 redis:7.4.1-alpine

# 启动Consul（可选，开发环境可以禁用）
docker run -d --name dev-consul -p 8500:8500 consul:1.17 agent -dev -client=0.0.0.0 -ui

# 验证服务
redis-cli ping
curl http://localhost:8500/v1/status/leader
```

#### 1.3.2 配置开发环境

```yaml
# src/main/resources/application-dev.yml
spring:
  profiles:
    active: dev
  cloud:
    consul:
      enabled: false
    gateway:
      discovery:
        locator:
          enabled: false

# 开发环境的静态路由配置
turms:
  gateway:
    services:
      turms-gateway:
        host: localhost
        port: 9510
        websocket-port: 10510
      turms-service:
        host: localhost
        port: 8510
      turms-tag-service:
        host: localhost
        port: 8085

logging:
  level:
    org.springframework.cloud.gateway: DEBUG
    im.turms.apigateway: DEBUG
```

#### 1.3.3 启动应用

```bash
# 方式1：Maven启动
cd turms-api-gateway
mvn spring-boot:run -Dspring-boot.run.profiles=dev

# 方式2：IDE启动
# 在IDE中设置启动参数：--spring.profiles.active=dev

# 验证启动
curl http://localhost:8080/actuator/health
```

## 2. 项目结构详解

### 2.1 目录结构

```
turms-api-gateway/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── im/turms/apigateway/
│   │   │       ├── TurmsApiGatewayApplication.java    # 主启动类
│   │   │       ├── config/                           # 配置类
│   │   │       │   ├── GatewayConfig.java           # 网关路由配置
│   │   │       │   └── SecurityConfig.java         # 安全配置
│   │   │       ├── filter/                          # 过滤器
│   │   │       │   ├── AuthenticationGatewayFilterFactory.java
│   │   │       │   └── LoggingGlobalFilter.java
│   │   │       ├── security/                        # 安全组件
│   │   │       │   └── JwtUtil.java                # JWT工具类
│   │   │       ├── exception/                       # 异常处理
│   │   │       │   └── FallbackController.java     # 降级控制器
│   │   │       └── util/                           # 工具类
│   │   │           └── ResponseUtil.java           # 响应工具
│   │   └── resources/
│   │       ├── application.yml                      # 主配置文件
│   │       └── logback-spring.xml                  # 日志配置
│   └── test/                                        # 测试代码
├── docker/                                          # Docker相关
│   ├── Dockerfile
│   ├── docker-compose.yml
│   └── monitoring/
├── pom.xml                                          # Maven配置
└── README.md                                        # 项目说明
```

### 2.2 核心组件

#### 2.2.1 主启动类

```java
@SpringBootApplication
@EnableDiscoveryClient
public class TurmsApiGatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(TurmsApiGatewayApplication.class, args);
    }
}
```

**关键注解说明：**
- `@SpringBootApplication`: Spring Boot主配置
- `@EnableDiscoveryClient`: 启用服务发现客户端

#### 2.2.2 路由配置

```java
@Configuration
public class GatewayConfig {
    
    @Bean
    public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        return builder.routes()
                .route("turms-service", r -> r
                        .path("/api/v1/im/**")
                        .filters(f -> f
                                .stripPrefix(3)
                                .circuitBreaker(c -> c.setName("turms-service"))
                                .requestRateLimiter(c -> c.setRateLimiter(redisRateLimiter())))
                        .uri("lb://turms-service"))
                .build();
    }
}
```

#### 2.2.3 过滤器链

```java
@Component
public class LoggingGlobalFilter implements GlobalFilter, Ordered {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 请求前处理
        return chain.filter(exchange)
                .then(Mono.fromRunnable(() -> {
                    // 请求后处理
                }));
    }
    
    @Override
    public int getOrder() {
        return -1; // 执行顺序
    }
}
```

## 3. 核心功能开发

### 3.1 自定义过滤器开发

#### 3.1.1 全局过滤器

```java
@Component
@Slf4j
public class CustomGlobalFilter implements GlobalFilter, Ordered {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        
        // 前置处理
        log.info("Processing request: {} {}", request.getMethod(), request.getURI());
        
        return chain.filter(exchange)
                .doOnSuccess(unused -> {
                    // 后置处理（成功）
                    ServerHttpResponse response = exchange.getResponse();
                    log.info("Request completed with status: {}", response.getStatusCode());
                })
                .doOnError(throwable -> {
                    // 后置处理（错误）
                    log.error("Request failed", throwable);
                });
    }

    @Override
    public int getOrder() {
        return 0; // 设置执行顺序
    }
}
```

#### 3.1.2 网关过滤器工厂

```java
@Component
public class CustomGatewayFilterFactory 
        extends AbstractGatewayFilterFactory<CustomGatewayFilterFactory.Config> {

    public CustomGatewayFilterFactory() {
        super(Config.class);
    }

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            ServerHttpRequest request = exchange.getRequest();
            
            // 自定义逻辑
            if (config.isEnabled()) {
                // 添加自定义头
                ServerHttpRequest modifiedRequest = request.mutate()
                        .header("X-Custom-Header", config.getHeaderValue())
                        .build();
                        
                return chain.filter(exchange.mutate().request(modifiedRequest).build());
            }
            
            return chain.filter(exchange);
        };
    }

    @Override
    public List<String> shortcutFieldOrder() {
        return Arrays.asList("enabled", "headerValue");
    }

    public static class Config {
        private boolean enabled = true;
        private String headerValue = "default";
        
        // getters and setters
    }
}
```

#### 3.1.3 配置使用自定义过滤器

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: custom-route
          uri: http://example.com
          predicates:
            - Path=/api/**
          filters:
            - name: Custom
              args:
                enabled: true
                headerValue: "custom-value"
```

### 3.2 路由断言开发

#### 3.2.1 自定义路由断言

```java
@Component
public class CustomRoutePredicateFactory 
        extends AbstractRoutePredicateFactory<CustomRoutePredicateFactory.Config> {

    public CustomRoutePredicateFactory() {
        super(Config.class);
    }

    @Override
    public Predicate<ServerWebExchange> apply(Config config) {
        return exchange -> {
            ServerHttpRequest request = exchange.getRequest();
            
            // 自定义断言逻辑
            String userAgent = request.getHeaders().getFirst("User-Agent");
            return userAgent != null && userAgent.contains(config.getUserAgentPattern());
        };
    }

    @Override
    public List<String> shortcutFieldOrder() {
        return Collections.singletonList("userAgentPattern");
    }

    public static class Config {
        private String userAgentPattern;
        
        // getters and setters
    }
}
```

#### 3.2.2 使用自定义断言

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: mobile-route
          uri: http://mobile-api.example.com
          predicates:
            - Custom=Mobile
            - Path=/api/mobile/**
```

### 3.3 负载均衡策略

#### 3.3.1 自定义负载均衡器

```java
@Component
public class CustomLoadBalancer implements ReactorServiceInstanceLoadBalancer {

    private final String serviceId;
    private final ObjectProvider<ServiceInstanceListSupplier> serviceInstanceListSupplierProvider;

    public CustomLoadBalancer(ObjectProvider<ServiceInstanceListSupplier> serviceInstanceListSupplierProvider,
                             String serviceId) {
        this.serviceId = serviceId;
        this.serviceInstanceListSupplierProvider = serviceInstanceListSupplierProvider;
    }

    @Override
    public Mono<Response<ServiceInstance>> choose(Request request) {
        ServiceInstanceListSupplier supplier = serviceInstanceListSupplierProvider
                .getIfAvailable(NoopServiceInstanceListSupplier::new);
                
        return supplier.get(request)
                .next()
                .map(serviceInstances -> processInstanceResponse(serviceInstances, request));
    }

    private Response<ServiceInstance> processInstanceResponse(
            List<ServiceInstance> serviceInstances, Request request) {
        
        if (serviceInstances.isEmpty()) {
            return new EmptyResponse();
        }

        // 自定义负载均衡逻辑
        ServiceInstance selectedInstance = selectInstance(serviceInstances, request);
        return new DefaultResponse(selectedInstance);
    }

    private ServiceInstance selectInstance(List<ServiceInstance> instances, Request request) {
        // 实现自定义选择逻辑，例如基于权重、响应时间等
        return instances.get(ThreadLocalRandom.current().nextInt(instances.size()));
    }
}
```

#### 3.3.2 配置自定义负载均衡器

```java
@Configuration
public class LoadBalancerConfiguration {

    @Bean
    @ConditionalOnProperty(value = "spring.cloud.loadbalancer.custom.enabled", havingValue = "true")
    public ReactorLoadBalancer<ServiceInstance> customLoadBalancer(
            Environment environment,
            LoadBalancerClientFactory loadBalancerClientFactory) {
        
        String name = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);
        return new CustomLoadBalancer(
                loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class),
                name);
    }
}
```

### 3.4 熔断器配置

#### 3.4.1 自定义熔断器

```java
@Configuration
public class CircuitBreakerConfiguration {

    @Bean
    public Customizer<ReactiveResilience4JCircuitBreakerFactory> customCircuitBreakerFactory() {
        return factory -> {
            factory.configure(builder -> builder
                    .circuitBreakerConfig(CircuitBreakerConfig.custom()
                            .slidingWindowSize(20)
                            .minimumNumberOfCalls(10)
                            .failureRateThreshold(60.0f)
                            .waitDurationInOpenState(Duration.ofSeconds(30))
                            .permittedNumberOfCallsInHalfOpenState(5)
                            .slowCallRateThreshold(50.0f)
                            .slowCallDurationThreshold(Duration.ofSeconds(3))
                            .build())
                    .timeLimiterConfig(TimeLimiterConfig.custom()
                            .timeoutDuration(Duration.ofSeconds(5))
                            .build())
                    .build(), "customCircuitBreaker");
        };
    }
}
```

#### 3.4.2 熔断器事件监听

```java
@Component
@Slf4j
public class CircuitBreakerEventListener {

    @EventListener
    public void onCircuitBreakerEvent(CircuitBreakerEvent event) {
        switch (event.getEventType()) {
            case STATE_TRANSITION:
                CircuitBreakerOnStateTransitionEvent stateTransitionEvent = 
                        (CircuitBreakerOnStateTransitionEvent) event;
                log.warn("Circuit breaker {} state transition from {} to {}", 
                        event.getCircuitBreakerName(),
                        stateTransitionEvent.getFromState(),
                        stateTransitionEvent.getToState());
                break;
            case FAILURE_RATE_EXCEEDED:
                log.error("Circuit breaker {} failure rate exceeded", 
                        event.getCircuitBreakerName());
                break;
            case SLOW_CALL_RATE_EXCEEDED:
                log.warn("Circuit breaker {} slow call rate exceeded", 
                        event.getCircuitBreakerName());
                break;
        }
    }
}
```

## 4. 监控与指标

### 4.1 自定义指标

#### 4.1.1 指标收集器

```java
@Component
@Slf4j
public class GatewayMetricsCollector {

    private final MeterRegistry meterRegistry;
    private final Counter requestCounter;
    private final Timer responseTimer;
    private final Gauge activeConnections;

    public GatewayMetricsCollector(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        
        this.requestCounter = Counter.builder("gateway.requests.total")
                .description("Total number of requests")
                .register(meterRegistry);
                
        this.responseTimer = Timer.builder("gateway.response.time")
                .description("Response time")
                .register(meterRegistry);
                
        this.activeConnections = Gauge.builder("gateway.connections.active")
                .description("Active connections")
                .register(meterRegistry, this, GatewayMetricsCollector::getActiveConnections);
    }

    public void incrementRequestCounter(String path, String method, String status) {
        requestCounter.increment(
                Tags.of(
                        Tag.of("path", path),
                        Tag.of("method", method),
                        Tag.of("status", status)
                )
        );
    }

    public Timer.Sample startTimer() {
        return Timer.start(meterRegistry);
    }

    public void recordTimer(Timer.Sample sample, String serviceName) {
        sample.stop(Timer.builder("gateway.request.duration")
                .tag("service", serviceName)
                .register(meterRegistry));
    }

    private double getActiveConnections() {
        // 获取活跃连接数的逻辑
        return 0.0;
    }
}
```

#### 4.1.2 指标过滤器

```java
@Component
public class MetricsGlobalFilter implements GlobalFilter, Ordered {

    private final GatewayMetricsCollector metricsCollector;

    public MetricsGlobalFilter(GatewayMetricsCollector metricsCollector) {
        this.metricsCollector = metricsCollector;
    }

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        Timer.Sample sample = metricsCollector.startTimer();

        return chain.filter(exchange)
                .doFinally(signalType -> {
                    ServerHttpResponse response = exchange.getResponse();
                    
                    // 记录指标
                    metricsCollector.incrementRequestCounter(
                            request.getPath().value(),
                            request.getMethod().name(),
                            response.getStatusCode().toString()
                    );
                    
                    // 记录响应时间
                    String serviceName = getServiceName(exchange);
                    metricsCollector.recordTimer(sample, serviceName);
                });
    }

    private String getServiceName(ServerWebExchange exchange) {
        Route route = exchange.getAttribute(ServerWebExchangeUtils.GATEWAY_ROUTE_ATTR);
        return route != null ? route.getId() : "unknown";
    }

    @Override
    public int getOrder() {
        return 0;
    }
}
```

### 4.2 健康检查

#### 4.2.1 自定义健康指示器

```java
@Component
public class GatewayHealthIndicator implements HealthIndicator {

    private final RedisTemplate<String, String> redisTemplate;
    private final DiscoveryClient discoveryClient;

    public GatewayHealthIndicator(RedisTemplate<String, String> redisTemplate,
                                 DiscoveryClient discoveryClient) {
        this.redisTemplate = redisTemplate;
        this.discoveryClient = discoveryClient;
    }

    @Override
    public Health health() {
        Health.Builder builder = Health.up();

        // 检查Redis连接
        try {
            redisTemplate.opsForValue().get("health-check");
            builder.withDetail("redis", "UP");
        } catch (Exception e) {
            builder.down().withDetail("redis", "DOWN: " + e.getMessage());
        }

        // 检查服务发现
        try {
            List<String> services = discoveryClient.getServices();
            builder.withDetail("discovery", "UP")
                   .withDetail("services", services.size());
        } catch (Exception e) {
            builder.down().withDetail("discovery", "DOWN: " + e.getMessage());
        }

        return builder.build();
    }
}
```

#### 4.2.2 就绪检查

```java
@Component
public class GatewayReadinessIndicator implements HealthIndicator {

    private final AtomicBoolean ready = new AtomicBoolean(false);

    @PostConstruct
    public void initialize() {
        // 执行初始化检查
        checkReadiness();
    }

    @Override
    public Health health() {
        if (ready.get()) {
            return Health.up()
                    .withDetail("status", "READY")
                    .build();
        } else {
            return Health.down()
                    .withDetail("status", "NOT_READY")
                    .build();
        }
    }

    private void checkReadiness() {
        // 检查所有依赖服务是否就绪
        boolean allReady = checkDependencies();
        ready.set(allReady);
    }

    private boolean checkDependencies() {
        // 实现依赖检查逻辑
        return true;
    }
}
```

## 5. 测试策略

### 5.1 单元测试

#### 5.1.1 过滤器测试

```java
@ExtendWith(MockitoExtension.class)
class AuthenticationGatewayFilterTest {

    @Mock
    private JwtUtil jwtUtil;

    @Mock
    private GatewayFilterChain chain;

    @Mock
    private ServerWebExchange exchange;

    @Mock
    private ServerHttpRequest request;

    @Mock
    private ServerHttpResponse response;

    private AuthenticationGatewayFilterFactory filterFactory;
    private GatewayFilter filter;

    @BeforeEach
    void setUp() {
        filterFactory = new AuthenticationGatewayFilterFactory(jwtUtil);
        filter = filterFactory.apply(new AuthenticationGatewayFilterFactory.Config());
    }

    @Test
    void shouldAllowPublicApi() {
        // Given
        when(exchange.getRequest()).thenReturn(request);
        when(request.getPath()).thenReturn(PathContainer.parsePath("/api/v1/public/test"));
        when(chain.filter(exchange)).thenReturn(Mono.empty());

        // When
        Mono<Void> result = filter.filter(exchange, chain);

        // Then
        StepVerifier.create(result)
                .verifyComplete();
        
        verify(chain).filter(exchange);
        verifyNoInteractions(jwtUtil);
    }

    @Test
    void shouldRejectInvalidToken() {
        // Given
        HttpHeaders headers = new HttpHeaders();
        headers.add("Authorization", "Bearer invalid-token");
        
        when(exchange.getRequest()).thenReturn(request);
        when(exchange.getResponse()).thenReturn(response);
        when(request.getPath()).thenReturn(PathContainer.parsePath("/api/v1/protected"));
        when(request.getHeaders()).thenReturn(headers);
        when(jwtUtil.validateToken("invalid-token")).thenReturn(false);
        when(response.setStatusCode(HttpStatus.UNAUTHORIZED)).thenReturn(true);
        when(response.setComplete()).thenReturn(Mono.empty());

        // When
        Mono<Void> result = filter.filter(exchange, chain);

        // Then
        StepVerifier.create(result)
                .verifyComplete();
                
        verify(response).setStatusCode(HttpStatus.UNAUTHORIZED);
        verify(jwtUtil).validateToken("invalid-token");
        verifyNoInteractions(chain);
    }
}
```

#### 5.1.2 工具类测试

```java
class JwtUtilTest {

    private JwtUtil jwtUtil;

    @BeforeEach
    void setUp() {
        jwtUtil = new JwtUtil();
        ReflectionTestUtils.setField(jwtUtil, "secret", "test-secret-key-must-be-at-least-32-characters");
        ReflectionTestUtils.setField(jwtUtil, "expiration", 3600L);
    }

    @Test
    void shouldGenerateValidToken() {
        // Given
        String userId = "user123";
        String role = "USER";

        // When
        String token = jwtUtil.generateToken(userId, role);

        // Then
        assertThat(token).isNotBlank();
        assertThat(jwtUtil.validateToken(token)).isTrue();
        assertThat(jwtUtil.getUserIdFromToken(token)).isEqualTo(userId);
        assertThat(jwtUtil.getUserRoleFromToken(token)).isEqualTo(role);
    }

    @Test
    void shouldRejectExpiredToken() {
        // Given
        ReflectionTestUtils.setField(jwtUtil, "expiration", -1L);
        String token = jwtUtil.generateToken("user123", "USER");

        // When
        boolean isValid = jwtUtil.validateToken(token);

        // Then
        assertThat(isValid).isFalse();
    }
}
```

### 5.2 集成测试

#### 5.2.1 网关集成测试

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestPropertySource(properties = {
        "spring.cloud.consul.enabled=false",
        "spring.cloud.gateway.discovery.locator.enabled=false"
})
class GatewayIntegrationTest {

    @Autowired
    private TestRestTemplate restTemplate;

    @LocalServerPort
    private int port;

    @MockBean
    private DiscoveryClient discoveryClient;

    @Test
    void shouldRouteToHealthEndpoint() {
        // When
        ResponseEntity<String> response = restTemplate.getForEntity(
                "http://localhost:" + port + "/actuator/health",
                String.class
        );

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).contains("\"status\":\"UP\"");
    }

    @Test
    void shouldRejectUnauthorizedRequest() {
        // When
        ResponseEntity<String> response = restTemplate.getForEntity(
                "http://localhost:" + port + "/api/v1/protected",
                String.class
        );

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
    }
}
```

#### 5.2.2 端到端测试

```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Testcontainers
class GatewayE2ETest {

    @Container
    static RedisContainer redis = new RedisContainer(DockerImageName.parse("redis:7.4.1-alpine"))
            .withExposedPorts(6379);

    @Container
    static GenericContainer<?> mockBackend = new GenericContainer<>("mockserver/mockserver:latest")
            .withExposedPorts(1080);

    @Autowired
    private WebTestClient webTestClient;

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.redis.host", redis::getHost);
        registry.add("spring.data.redis.port", redis::getFirstMappedPort);
        registry.add("turms.gateway.services.mock-service.host", mockBackend::getHost);
        registry.add("turms.gateway.services.mock-service.port", mockBackend::getFirstMappedPort);
    }

    @Test
    void shouldRouteRequestToBackendService() {
        // Given
        setupMockBackend();

        // When & Then
        webTestClient.get()
                .uri("/api/v1/test")
                .header("Authorization", "Bearer " + generateValidToken())
                .exchange()
                .expectStatus().isOk()
                .expectBody(String.class)
                .value(body -> assertThat(body).contains("mock response"));
    }

    private void setupMockBackend() {
        // 配置Mock服务器响应
    }

    private String generateValidToken() {
        // 生成测试用的有效JWT token
        return "test-token";
    }
}
```

### 5.3 性能测试

#### 5.3.1 JMH基准测试

```java
@BenchmarkMode(Mode.Throughput)
@OutputTimeUnit(TimeUnit.SECONDS)
@State(Scope.Benchmark)
@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)
@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)
@Fork(1)
public class JwtUtilBenchmark {

    private JwtUtil jwtUtil;
    private String token;

    @Setup
    public void setup() {
        jwtUtil = new JwtUtil();
        ReflectionTestUtils.setField(jwtUtil, "secret", "test-secret-key-must-be-at-least-32-characters");
        ReflectionTestUtils.setField(jwtUtil, "expiration", 3600L);
        token = jwtUtil.generateToken("user123", "USER");
    }

    @Benchmark
    public String generateToken() {
        return jwtUtil.generateToken("user123", "USER");
    }

    @Benchmark
    public boolean validateToken() {
        return jwtUtil.validateToken(token);
    }

    @Benchmark
    public String extractUserId() {
        return jwtUtil.getUserIdFromToken(token);
    }
}
```

#### 5.3.2 负载测试

```java
@Test
public void loadTest() throws InterruptedException {
    int threadCount = 100;
    int requestsPerThread = 1000;
    CountDownLatch latch = new CountDownLatch(threadCount);
    AtomicInteger successCount = new AtomicInteger(0);
    AtomicInteger errorCount = new AtomicInteger(0);

    ExecutorService executor = Executors.newFixedThreadPool(threadCount);

    long startTime = System.currentTimeMillis();

    for (int i = 0; i < threadCount; i++) {
        executor.submit(() -> {
            try {
                for (int j = 0; j < requestsPerThread; j++) {
                    try {
                        ResponseEntity<String> response = restTemplate.getForEntity(
                                "http://localhost:" + port + "/actuator/health",
                                String.class
                        );
                        if (response.getStatusCode().is2xxSuccessful()) {
                            successCount.incrementAndGet();
                        } else {
                            errorCount.incrementAndGet();
                        }
                    } catch (Exception e) {
                        errorCount.incrementAndGet();
                    }
                }
            } finally {
                latch.countDown();
            }
        });
    }

    latch.await();
    executor.shutdown();

    long endTime = System.currentTimeMillis();
    long totalTime = endTime - startTime;
    int totalRequests = threadCount * requestsPerThread;

    System.out.println("Total requests: " + totalRequests);
    System.out.println("Success: " + successCount.get());
    System.out.println("Errors: " + errorCount.get());
    System.out.println("Total time: " + totalTime + "ms");
    System.out.println("Throughput: " + (totalRequests * 1000.0 / totalTime) + " requests/second");

    assertThat(successCount.get()).isGreaterThan(totalRequests * 0.95); // 95%成功率
}
```

## 6. 调试与故障排查

### 6.1 日志配置

#### 6.1.1 开发环境日志

```yaml
logging:
  level:
    org.springframework.cloud.gateway: DEBUG
    org.springframework.cloud.loadbalancer: DEBUG
    org.springframework.security: DEBUG
    im.turms.apigateway: DEBUG
    reactor.netty: DEBUG
  pattern:
    console: "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
```

#### 6.1.2 结构化日志

```java
@Component
@Slf4j
public class StructuredLoggingFilter implements GlobalFilter {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String requestId = UUID.randomUUID().toString();
        
        // 添加到MDC
        MDC.put("requestId", requestId);
        MDC.put("method", request.getMethod().name());
        MDC.put("path", request.getPath().value());

        long startTime = System.currentTimeMillis();

        return chain.filter(exchange)
                .doFinally(signalType -> {
                    long endTime = System.currentTimeMillis();
                    ServerHttpResponse response = exchange.getResponse();
                    
                    // 结构化日志
                    Map<String, Object> logData = Map.of(
                            "requestId", requestId,
                            "method", request.getMethod().name(),
                            "path", request.getPath().value(),
                            "status", response.getStatusCode().value(),
                            "duration", endTime - startTime,
                            "userAgent", request.getHeaders().getFirst("User-Agent"),
                            "remoteAddr", getClientIP(request)
                    );

                    try {
                        log.info("Request processed: {}", objectMapper.writeValueAsString(logData));
                    } catch (Exception e) {
                        log.error("Failed to serialize log data", e);
                    }

                    // 清理MDC
                    MDC.clear();
                });
    }

    private String getClientIP(ServerHttpRequest request) {
        String xForwardedFor = request.getHeaders().getFirst("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        String xRealIP = request.getHeaders().getFirst("X-Real-IP");
        if (xRealIP != null && !xRealIP.isEmpty()) {
            return xRealIP;
        }
        return request.getRemoteAddress() != null ? 
                request.getRemoteAddress().getAddress().getHostAddress() : "unknown";
    }
}
```

### 6.2 调试工具

#### 6.2.1 Actuator端点

```yaml
management:
  endpoints:
    web:
      exposure:
        include: "*"
  endpoint:
    gateway:
      enabled: true
    health:
      show-details: always
```

#### 6.2.2 自定义调试端点

```java
@RestController
@RequestMapping("/debug")
public class DebugController {

    private final GatewayProperties gatewayProperties;
    private final RouteLocator routeLocator;

    @GetMapping("/routes")
    public Flux<Map<String, Object>> getRoutes() {
        return routeLocator.getRoutes()
                .map(route -> Map.of(
                        "id", route.getId(),
                        "uri", route.getUri().toString(),
                        "predicates", route.getPredicates().toString(),
                        "filters", route.getFilters().toString()
                ));
    }

    @GetMapping("/config")
    public Map<String, Object> getConfig() {
        return Map.of(
                "globalFilters", gatewayProperties.getGlobalFilters(),
                "defaultFilters", gatewayProperties.getDefaultFilters(),
                "routes", gatewayProperties.getRoutes().size()
        );
    }
}
```

### 6.3 性能分析

#### 6.3.1 监控关键指标

```java
@Component
public class PerformanceMonitor {

    private final MeterRegistry meterRegistry;
    private final Timer requestTimer;
    private final Counter errorCounter;
    private final Gauge memoryGauge;

    public PerformanceMonitor(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.requestTimer = Timer.builder("gateway.request.duration")
                .description("Request processing time")
                .register(meterRegistry);
        this.errorCounter = Counter.builder("gateway.errors.total")
                .description("Total error count")
                .register(meterRegistry);
        this.memoryGauge = Gauge.builder("jvm.memory.usage")
                .description("JVM memory usage")
                .register(meterRegistry, this, PerformanceMonitor::getMemoryUsage);
    }

    public void recordRequestTime(Duration duration, String path) {
        requestTimer.record(duration, Tags.of("path", path));
    }

    public void incrementErrorCount(String errorType) {
        errorCounter.increment(Tags.of("type", errorType));
    }

    private double getMemoryUsage() {
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        MemoryUsage heapMemoryUsage = memoryBean.getHeapMemoryUsage();
        return (double) heapMemoryUsage.getUsed() / heapMemoryUsage.getMax();
    }
}
```

#### 6.3.2 内存分析

```java
@Component
public class MemoryAnalyzer {

    @EventListener
    @Async
    public void handleOutOfMemoryError(OutOfMemoryErrorEvent event) {
        try {
            // 生成堆转储
            String fileName = "heap-dump-" + System.currentTimeMillis() + ".hprof";
            Path dumpPath = Paths.get("dumps", fileName);
            Files.createDirectories(dumpPath.getParent());
            
            MBeanServer server = ManagementFactory.getPlatformMBeanServer();
            HotSpotDiagnosticMXBean mxBean = ManagementFactory.newPlatformMXBeanProxy(
                    server, "com.sun.management:type=HotSpotDiagnostic", HotSpotDiagnosticMXBean.class);
            mxBean.dumpHeap(dumpPath.toString(), true);
            
            log.error("Heap dump created: {}", dumpPath);
        } catch (Exception e) {
            log.error("Failed to create heap dump", e);
        }
    }
}
```

## 7. 最佳实践

### 7.1 代码规范

#### 7.1.1 命名规范

```java
// 类命名：使用PascalCase
public class UserAuthenticationFilter implements GatewayFilter { }

// 方法命名：使用camelCase，动词开头
public Mono<Void> authenticateUser(ServerWebExchange exchange) { }

// 常量命名：使用UPPER_SNAKE_CASE
private static final String AUTHORIZATION_HEADER = "Authorization";
private static final int DEFAULT_TIMEOUT_SECONDS = 30;

// 配置属性：使用kebab-case
@ConfigurationProperties("turms.api-gateway")
public class ApiGatewayProperties { }
```

#### 7.1.2 异常处理

```java
@Component
public class GlobalExceptionHandler implements ErrorWebExceptionHandler {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    public Mono<Void> handle(ServerWebExchange exchange, Throwable ex) {
        ServerHttpResponse response = exchange.getResponse();
        
        if (ex instanceof ResponseStatusException) {
            ResponseStatusException rse = (ResponseStatusException) ex;
            return handleResponseStatusException(response, rse);
        } else if (ex instanceof TimeoutException) {
            return handleTimeoutException(response, ex);
        } else {
            return handleGenericException(response, ex);
        }
    }

    private Mono<Void> handleResponseStatusException(ServerHttpResponse response, 
                                                   ResponseStatusException ex) {
        response.setStatusCode(ex.getStatusCode());
        return writeErrorResponse(response, ex.getReason(), ex.getStatusCode().value());
    }

    private Mono<Void> handleTimeoutException(ServerHttpResponse response, Throwable ex) {
        response.setStatusCode(HttpStatus.GATEWAY_TIMEOUT);
        return writeErrorResponse(response, "服务响应超时", 504);
    }

    private Mono<Void> handleGenericException(ServerHttpResponse response, Throwable ex) {
        log.error("Unhandled exception", ex);
        response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);
        return writeErrorResponse(response, "内部服务错误", 500);
    }

    private Mono<Void> writeErrorResponse(ServerHttpResponse response, String message, int status) {
        response.getHeaders().setContentType(MediaType.APPLICATION_JSON);
        
        Map<String, Object> errorBody = Map.of(
                "error", "GATEWAY_ERROR",
                "message", message,
                "status", status,
                "timestamp", Instant.now().toString()
        );

        try {
            DataBuffer buffer = response.bufferFactory().wrap(
                    objectMapper.writeValueAsBytes(errorBody));
            return response.writeWith(Mono.just(buffer));
        } catch (Exception e) {
            log.error("Failed to write error response", e);
            return response.setComplete();
        }
    }
}
```

### 7.2 性能优化

#### 7.2.1 连接池优化

```yaml
spring:
  data:
    redis:
      lettuce:
        pool:
          max-active: 16      # 最大连接数
          max-idle: 8         # 最大空闲连接数
          min-idle: 4         # 最小空闲连接数
          max-wait: 3000ms    # 最大等待时间
        shutdown-timeout: 100ms
  cloud:
    gateway:
      httpclient:
        pool:
          max-connections: 1000      # 最大连接数
          max-idle-time: 30s         # 最大空闲时间
          max-life-time: 60s         # 最大生存时间
        connect-timeout: 3000        # 连接超时
        response-timeout: 30s        # 响应超时
```

#### 7.2.2 内存优化

```yaml
# JVM参数优化
spring:
  application:
    name: turms-api-gateway
    
# 自定义配置
turms:
  gateway:
    cache:
      route-cache-size: 1000
      jwt-cache-size: 10000
      jwt-cache-ttl: 300s
```

#### 7.2.3 缓存策略

```java
@Configuration
@EnableCaching
public class CacheConfiguration {

    @Bean
    public CacheManager cacheManager() {
        RedisCacheManager.Builder builder = RedisCacheManager.RedisCacheManagerBuilder
                .fromConnectionFactory(redisConnectionFactory())
                .cacheDefaults(cacheConfiguration());
        return builder.build();
    }

    private RedisCacheConfiguration cacheConfiguration() {
        return RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(5))
                .serializeKeysWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new GenericJackson2JsonRedisSerializer()));
    }

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        LettuceConnectionFactory factory = new LettuceConnectionFactory();
        factory.setHostName("localhost");
        factory.setPort(6379);
        return factory;
    }
}
```

### 7.3 安全最佳实践

#### 7.3.1 安全配置

```java
@Configuration
@EnableWebFluxSecurity
public class SecurityConfiguration {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        return http
                .csrf(csrf -> csrf.disable())
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .headers(headers -> headers
                        .frameOptions(ServerHttpSecurity.HeaderSpec.FrameOptionsSpec::deny)
                        .contentTypeOptions(Customizer.withDefaults())
                        .httpStrictTransportSecurity(hssts -> hssts
                                .maxAgeInSeconds(31536000)
                                .includeSubdomains(true)))
                .authorizeExchange(exchanges -> exchanges
                        .pathMatchers("/actuator/health", "/actuator/info").permitAll()
                        .pathMatchers("/admin/**").hasRole("ADMIN")
                        .anyExchange().authenticated())
                .build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOriginPatterns(List.of("https://*.turms.im"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}
```

#### 7.3.2 输入验证

```java
@Component
public class RequestValidationFilter implements GlobalFilter {

    private static final Pattern VALID_PATH_PATTERN = Pattern.compile("^[a-zA-Z0-9/_-]+$");
    private static final int MAX_HEADER_SIZE = 8192;

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        
        // 验证请求路径
        if (!isValidPath(request.getPath().value())) {
            return ResponseUtil.writeErrorResponse(
                    exchange.getResponse(), 
                    HttpStatus.BAD_REQUEST, 
                    "Invalid request path");
        }
        
        // 验证请求头大小
        if (getTotalHeaderSize(request) > MAX_HEADER_SIZE) {
            return ResponseUtil.writeErrorResponse(
                    exchange.getResponse(), 
                    HttpStatus.REQUEST_HEADER_FIELDS_TOO_LARGE, 
                    "Request headers too large");
        }
        
        return chain.filter(exchange);
    }

    private boolean isValidPath(String path) {
        return path != null && 
               path.length() <= 2048 && 
               VALID_PATH_PATTERN.matcher(path).matches();
    }

    private int getTotalHeaderSize(ServerHttpRequest request) {
        return request.getHeaders().entrySet().stream()
                .mapToInt(entry -> entry.getKey().length() + 
                         entry.getValue().stream().mapToInt(String::length).sum())
                .sum();
    }
}
```

### 7.4 部署最佳实践

#### 7.4.1 Docker优化

```dockerfile
# 多阶段构建
FROM maven:3.9-openjdk-21-slim AS builder
WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN mvn clean package -DskipTests

FROM openjdk:21-jre-slim
WORKDIR /app

# 创建非root用户
RUN groupadd -r turms && useradd -r -g turms turms

# 复制应用
COPY --from=builder /app/target/turms-api-gateway-*.jar app.jar
COPY --chown=turms:turms docker/entrypoint.sh ./

# 设置权限
RUN chmod +x entrypoint.sh

# 健康检查
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# 切换用户
USER turms

# 启动
ENTRYPOINT ["./entrypoint.sh"]
```

#### 7.4.2 Kubernetes部署优化

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: turms-api-gateway
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  template:
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 1000
      containers:
      - name: api-gateway
        image: turms/api-gateway:latest
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 3
```

---

**总结**

本开发者指南涵盖了Turms API网关的完整开发流程，从环境搭建到部署上线。遵循这些最佳实践可以确保构建出高质量、高性能、安全可靠的网关服务。

**技术支持**

如有开发相关问题，请参考：
- 项目文档：https://docs.turms.im
- 源码仓库：https://github.com/turms-im/turms
- 社区讨论：https://github.com/turms-im/turms/discussions